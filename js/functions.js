/*

Success: unknown variable -> known,
Info: number of known and unknown variables and the number of equations you need to solve the problem and how many unique equations you have
Warning: tells you when you are using irrelevant equations, when variables with unknown units dont match on different lines, when simplifications could be done wrong
Error: dimensional analysis fails on a line

*/


function InitEditorWithEditorData(){
  let data = JSON.parse(JSON.stringify(EditorData));
  SimilarDefinedVariables = (data.SimilarDefinedVariables) ? data.SimilarDefinedVariables : {};
  DefinedVariables = (data.DefinedVariables) ? data.DefinedVariables : {};
  //using object.assign because PreDefinedVariables already has stuff in it so if the user wants to add more stuff they can
  Object.assign(PreDefinedVariables, (data.PreDefinedVariables ? data.PreDefinedVariables : {}));
  EL.undefinedVars = (data.UndefinedVars) ? data.UndefinedVars : {undefined: {}, defined: {},};
  LastVariableRIDChangedToGiven = data.LastVariableRIDChangedToGiven;
  SelectPhysicsConstants(PreDefinedVariables);
  InitMathFields(data.MathFieldsLatex, data.OrderedIds);
  //FocusOnThisMathField(data.FocusedMathFieldId);
}

function SelectPhysicsConstants(vars){
  for(const [key, value] of Object.entries(vars)){
    if(value.type == "physics constant"){
      let ridOfPhysicsConstantCheckBox = $(`.physics-constant-checkbox-span[symbol='${key}']`).attr("rid");
      $(`.physics-constant-checkbox-input[rid='${ridOfPhysicsConstantCheckBox}']`).prop("checked", true);
    }
  }
}

function InitMathFields(mathFieldsLatex, orderedIds){
  //this function takes mathfields and orderedIds and initializes all of them
  //we always initialize the first mathfield regardless if there is data or not
  CreateNewMathField("first_math_field");
  //because we are going to be editing a lot of mathfields we want to turn off parsing then edit all the mathfields then turn it on again that is what this boolean allows us to do
  EditingMathFields = true;
  if(Object.keys(mathFieldsLatex).length > 0){//there are mathfields to render
    for(const [key, value] of Object.entries(orderedIds)){
      if(value == "first_math_field"){
        MathFields[value].mf.write(mathFieldsLatex[value]);
      }else{
        AddNewEditorLineToEnd(value);
        MathFields[value].mf.write(mathFieldsLatex[value]);
      }
      UpdateLineLabelHeight(value);//updating the height of the mathfield when we inject the data
    }
  }
  EditingMathFields = false;//turning parsing back on and only parsing all this data once instead of every time we add a new mathfield
  
  EL.GenerateEditorErrorMessages();
  CheckIfAutoGeneratedVariablesAreBeingUsed();
  DisablePhysicsConstantCheckboxesThatAreBeingUsed();
  
}

function ClearEditorData(){
  SaveEditorData = false;
  location.reload();
}

function SaveEditorDataToLocalStorage(){
  //we need to get all the mathfields latex
  let mathFieldsLatex = {};
  for(const [key, value] of Object.entries(MathFields)){
    mathFieldsLatex[key] = value.mf.latex();
  }
  try{
    let data = {
      SimilarDefinedVariables: SimilarDefinedVariables,
      DefinedVariables: DefinedVariables,
      PreDefinedVariables: PreDefinedVariables,
      UndefinedVars: EL.undefinedVars,
      MathFieldsLatex: mathFieldsLatex,
      OrderedIds: OrderMathFieldIdsByLineNumber(Object.keys(MathFields)),
      FocusedMathFieldId: FocusedMathFieldId,
      LastVariableRIDChangedToGiven: LastVariableRIDChangedToGiven,
    };
    localStorage.setItem("editor-data",JSON.stringify(data));
    localStorage.setItem("prev-error", 'none');
  }catch(err){
    localStorage.setItem("prev-error", err.toString());
  } 
}

function replaceLatexKeywordsWithSpace(latexString){
  let cmds = ["\\sqrt","\\frac"];
  for(var i = 0; i < cmds.length; i++){
    latexString = latexString.replace(cmds[i], new Array(cmds[i].length + 1).join(" "));
  }

  return latexString;

}

function SelectedStringPossibleVariable(str){
  //looking for any characters that is not a word or white space
  return str.search(/\+|\-|\*|\^|\\cdot/g) == -1;
}

function SelectedStringDefined(str){
  return str in DefinedVariables;
}

function RenderImportedVariablesTable(type, index){
  let headers = {
    mechanics: "Import Mechanics Variables Definitions",
    thermal: "Import Thermal Variables Definitions",
    waveOptics: "Import Wave Optics Variables Definitions",
    em: "Import Electricity & Magnetism Variables Definitions",
    modern: "Import Modern Physics Variables Definitions",
  }
  
  let vars = Object.assign({}, ImportVariableDefinitions[type]);
  //we are going to go through vars and add information to it so that we know if a checkbox should be check, unchecked, or disabled
  for(const [key, value] of Object.entries(vars)){
    vars[key].checked = false;//variable should be unchchecked until we can prove that the user has already imported it
    vars[key].disabled = false;
    if(SimilarDefinedVariables[key] != undefined){
      if(SimilarDefinedVariables[key].rid == value.rid){//this means that the user has imported this variable so when they open up the import modal again the variable should already be checked
        vars[key].checked = true;
      }
      else{//this means that the user has imported a variable with the same ls but from a different section like modern physics or thermal so we must disable this option so that the definitions don't collide with each other
        vars[key].disabled = true;
      }
    }
  }

  //now we need to render the object, then inject the html into the modal
  let html = ejs.render(Templates["imported-variables-modal-content"], {header: headers[type], importedVariables: vars});
  $("#import-variable-definition-modal-content").html(html);
  //render the latex strings
  $("#modal_import_variable_definition .static-physics-equation").each(function(i){
    MQ.StaticMath($(this).get(0)).latex($(this).attr("latex"));
  });
  //add event listeners for checkboxes
  $("#import-all-variables").change(function(){
    $("#btn-update-imported-variables").removeClass("disabled");
    if($(this).prop("checked")){
      //making sure to only check variables that are not disabled
      $(".variable-checkbox:not([disabled='disabled']").prop("checked",true);
    }
    else{
      $(".variable-checkbox").prop("checked",false);
    }
  });

  $(".variable-checkbox").change(function(){
    $("#btn-update-imported-variables").removeClass("disabled");
  });
  //now open the modal
  $("#modal_import_variable_definition").modal("open");
  $("#import-variable-definition-modal-content").scrollTop(0)

  $(".already-imported-variable.tooltipped").tooltip();
  
}

function OpenCollapsibleSection(index){
  /*
  $("#physics_equations .collapsible").collapsible("close",0);
  $("#physics_equations .collapsible").collapsible("close",1);
  $("#physics_equations .collapsible").collapsible("close",2);
  $("#physics_equations .collapsible").collapsible("close",3);
  $("#physics_equations .collapsible").collapsible("close",4);
  $("#physics_equations .collapsible").collapsible("open",index);
  */
}

function UpdateImportedVariables(){
  //we need to go through all the checkboxes and add the ones that are checked and remove the ones that are not checked
  $("#import-variable-definition-modal-content tbody .variable-checkbox").each(function(){
    let ls = $(this).attr("latex");
    if($(this).prop("checked")){
      let variableRid = $(this).attr("rid");
      let props = {};
      //getting the properties of this specific variable
      for(const [key, value] of Object.entries(ImportVariableDefinitions)){
        if(value[ls] != undefined){
          if(value[ls].rid == variableRid){
            props = {
              state: "unknown",
              type: (value[ls].vector) ? "vector" : "scalar",
              units: TrimUnitInputValue(CreateFullUnitsString(value[ls].quantity, ListOfSIUnits[value[ls].quantity].name, ListOfSIUnits[value[ls].quantity].symbol)),
              unitsMathjs: value[ls].unitsMathjs,
              quantity: value[ls].quantity,
              rid: value[ls].rid,
              canBeVector: value[ls].vector,
            };
            break;//we found the variable we are looking for and got all the information we need from it so we out
          }
        }
      }
      //then we update to import the variable in
      UpdateSimilarDefinedVariables({
        type: "update",
        ls: ls,
        props: props,
      });
      //if the variable is a vector we are also going to import its magnitude
      if(IsVariableLatexStringVector(ls)){
        props.type = "scalar"
        UpdateSimilarDefinedVariables({
          type: "update",
          ls: RemoveVectorLatexString(ls),//this takes a latex string \vec{a} and returns a
          props: props,
        });
      }
    }
    else{
      //if it wasn't checked it could have been disabled because it is already imported so we need to make sure that it wasn't disabled and if it was don't do anything don't remove anything
      if($(this).attr("disabled") != "disabled"){
        //if it is not checked we need to remove it
        UpdateSimilarDefinedVariables({
          type: "remove",
          ls: ls,
        });
        //if the variable is a vector we need to try to remove its magnitude as well
        if(IsVariableLatexStringVector(ls)){
          UpdateSimilarDefinedVariables({
            type: "remove",
            ls: RemoveVectorLatexString(ls),
          });
        }
      }
    }
  });

  $("#modal_import_variable_definition").modal("close");

  //we need to run error logger again because we have updated the imported variables
  //console.log("UpdateImportedVariables");
  DisplayLoadingBar(true);
  ExecutionID = RID();
  (debounce(function(executionID){
    if(executionID == ExecutionID){
      //console.log("currently parsing", EL.currentlyParsing);
      EL.GenerateEditorErrorMessages();
      DisplayLoadingBar(false);
    }
    
  }, 500))(ExecutionID);
}


function UpdateSimilarDefinedVariables(opts){
  if(opts.type == "update"){
    SimilarDefinedVariables[opts.ls] = {
      state: opts.props.state,
      type: opts.props.type,
      units: opts.props.units,
      unitsMathjs: opts.props.unitsMathjs,
      quantity: opts.props.quantity,
      rid: opts.props.rid,
      canBeVector: opts.props.canBeVector
    };
  }
  else if(opts.type == "remove"){
    delete SimilarDefinedVariables[opts.ls];
  }
}

function RemoveVectorLatexString(ls){
  let startIndex = ls.indexOf("\\vec{") + "\\vec{".length;
  let i = FindIndexOfClosingBracket(ls.substring(startIndex));
  if(i != null){
    return ls.substring(startIndex, i + startIndex);
  }
  return null;
}

function RemoveBarAndOverlineFromLatexString(ls){
  let startIndex, i;
  while(ls.indexOf("\\bar{") != -1){
    startIndex = ls.indexOf("\\bar{") + "\\bar{".length;
    i = FindIndexOfClosingBracket(ls.substring(startIndex));
    if(i != null){
      ls = ls.substring(startIndex, i + startIndex);
    }
  }

  while(ls.indexOf("\\overline{") != -1){
    startIndex = ls.indexOf("\\overline{") + "\\overline{".length;
    i = FindIndexOfClosingBracket(ls.substring(startIndex));
    if(i != null){
      ls = ls.substring(startIndex, i + startIndex);
    }
  }

  return ls;
}


function UpdateDefinedVariables(opts){
  if(opts.type == "add" || opts.type == "update"){
    if(opts.editable){
      let rid = (DefinedVariables[opts.ls] == undefined) ? RID(): DefinedVariables[opts.ls].rid;
      DefinedVariables[opts.ls] = opts.props;
      DefinedVariables[opts.ls].rid = rid;
      DefinedVariables[opts.ls].autoGenerated = opts.autoGenerated || false;
    }
    else{
      PreDefinedVariables[opts.ls] = opts.props;
      PreDefinedVariables[opts.ls].rid = opts.rid;
      //after we add a new variable as a predefined variable we need to make sure to remove any defined variable that uses that same ls
      if(DefinedVariables[opts.ls] != undefined){
        UpdateDefinedVariables({
          type: "remove",
          rid: DefinedVariables[opts.ls].rid,
          editable: true,
        });
      }
      
    }
  }
  else if(opts.type == "remove"){
    if(opts.editable){
      for (let [key, value] of Object.entries(DefinedVariables)) {
        if(value.rid == opts.rid){
          if(opts.addToUndefinedVariables){
            // before we remove this variable from DefinedVariables we want to move the data to EL.undefinedVars.undefined
            // so that we keep track of the undefined variables before we run another set of error messages where we save
            // the old undefined variables data
            EL.recordOneUndefinedVariable(key, value);
          }
          delete DefinedVariables[key];
          break;
        }
      }
    }
    else{
      for (let [key, value] of Object.entries(PreDefinedVariables)) {
        if(value.rid == opts.rid){
          delete PreDefinedVariables[key];
          break;
        }
      }
    }
  }

  if(opts.updateErrorMessages != false){
    //after editing we need to check if there are any new Editor errors
    //console.log("UpdateDefinedVariables");
    //we are not debouncing this "EL.GenerateEditorErrorMessages()" because every call done to "UpdateDefinedVariables()" stems
    //from a manual action meaning that if we write blocking code that has to run error checking before it renders the next thing
    //the user types its ok because the user is not typing. Additionally, for some reason we were getting some weird "ghost"
    //variables popuping up when we debounced it. I think a Global Object representing one of the many types of variables was
    //getting edited while a debounced function was using it to render the "variables collection"
    DisplayLoadingBar(true);
    ExecutionID = RID();
    EL.GenerateEditorErrorMessages();
    DisplayLoadingBar(false);
    /*
    (debounce(function(executionID){
      if(executionID == ExecutionID){
        //console.log("UpdateDefinedVariables got through");
        //console.log("currently parsing", EL.currentlyParsing);
        EL.GenerateEditorErrorMessages();
        DisplayLoadingBar(false);
      }
      
    }, 10))(ExecutionID);*/
  }

}

function IsVariableLatexStringVector(ls){
  return ls.indexOf("\\vec{") != -1 || ls.indexOf("\\hat{") != -1;
}

function GetFullUnitsStringFromUnitsMathJs(unitsMathjs){
  //this function takes a unitsMathjs variable and tries to find the SI Unit that matches it
  //if it can't find the unit it returns null
  unitsMathjs = (unitsMathjs.indexOf("vector") != -1) ? GetUnitsFromMathJsVectorString(unitsMathjs) : unitsMathjs;
  for(const [key, value] of Object.entries(ListOfSIUnits)){
    try{
      //if this line doesn't through an error than these two units are equal and we have found our match
      math.evaluate(`${value.unitsMathjs} + ${unitsMathjs}`);
      return {str: CreateFullUnitsString(key, value.name, value.symbol), custom: false, canBeVector: value.canBeVector, unitsMathjs: value.unitsMathjs, units: `${key} (${value.symbol})`, quantity: key, };
    }
    catch(err){}
  }
  //if we couldn't identify the unit then we assume it is custom so we need to return the unit back to them but without any constants in front of it
  let unitsMathjs2 = unitsMathjs.split(" ");
  unitsMathjs2.splice(0,1);//removing constants infront of units string
  unitsMathjs2 = unitsMathjs2.join(" ");
  return {str: unitsMathjs2, custom: true, canBeVector: true, unitsMathjs: unitsMathjs, units: unitsMathjs2, };
}

function ToggleVariableState(rid){
  let foundVariable = false;

  LastVariableRIDChangedToGiven = null;

  for(const [key, value] of Object.entries(DefinedVariables)){
    if(value.rid == rid){
      let ls = key;
      let props = Object.assign({},value);
      //changing the state
      if(props.state == "given"){
        props.state = "unknown";
      }
      else{
        props.state = "given";
        //if the state is set to given then we need to focus the variable value tag
        LastVariableRIDChangedToGiven = rid;
      }
      UpdateDefinedVariables({
        type: "update",
        ls: ls,
        editable: true,
        props: props,
      });
      break;
    }
  }

  if(!foundVariable){
    for(const [key, value] of Object.entries(EL.undefinedVars.undefined)){
      if(value.rid == rid){
        //changing the state
        foundVariable = true;
        if(EL.undefinedVars.undefined[key].state == "given"){
          EL.undefinedVars.undefined[key].state = "unknown";
        }
        else{
          EL.undefinedVars.undefined[key].state = "given";
          LastVariableRIDChangedToGiven = rid;
        }
        break;
      }
    }
  }

  if(!foundVariable){
    for(const [key, value] of Object.entries(EL.undefinedVars.defined)){
      if(value.rid == rid){
        //changing the state
        foundVariable = true;
        if(EL.undefinedVars.defined[key].state == "given"){
          EL.undefinedVars.defined[key].state = "unknown";
        }
        else{
          LastVariableRIDChangedToGiven = rid;
          EL.undefinedVars.defined[key].state = "given";
        }
        break;
      }
    }
  }

  //because we changed the state of a variable we need to update the known and unknown status of all the other variables based on the change
  EL.UpdateKnownUnknownVariables();

  //then after we have edited either DefinedVariables or EL.undefinedVars.defined then we need to update the collection with the new information
  UpdateMyVariablesCollection({update: true});
}

function TrimUnitInputValue(str){
  let start = str.indexOf(":");
  let end = str.indexOf("(");
  if(start != -1 && end != -1){
    str = str.substring(0,start) + " " + str.substring(end);
  }

  return str;
}

function AddNewEditorLineToEnd(rid = undefined){
  MathFieldKeyPressEnter($("#math_field_editor_container .editor_line:last-child"),false, rid);
}

function MathFieldKeyPressEnter(el, enterClicked = false, RId = undefined){
  //first we need to copy everything after the cursor so that when we go to the next line that information goes to the next line and is removed from the current line
  let lsForNextLine = "";
  if(enterClicked){
    let lsBeforeBackspace = MathFields[FocusedMathFieldId].mf.latex();
    MathFields[FocusedMathFieldId].mf.keystroke("Shift-Down");
    MathFields[FocusedMathFieldId].mf.write("");
    UpdateLineLabelHeight(FocusedMathFieldId);//adjusting the line label height because this math field has changed
    let lsAfterBackspace = MathFields[FocusedMathFieldId].mf.latex();
    //removes the first instance of the information that came before the cursor. it only removes the first because we are passing in a string and not a regex expression
    lsForNextLine = lsBeforeBackspace.replace(lsAfterBackspace, "");
  }
  //create a new div element then initialize a math field in it
  let rid = (RId != undefined) ? RId : RID(); 
  let html = ejs.render(Templates["editor-line"], {rid: rid});
  $(html).insertAfter(el);

  FocusedMathFieldId = rid;
  SetMathFieldsUI();

  AdjustLineLabelNumber();//make sure that the line is label with the correct number

  CreateNewMathField(rid);

  if(enterClicked){
    //after we create the new mathfield we need to give it the information that was entered down into the next line
    MathFields[FocusedMathFieldId].mf.latex(lsForNextLine);
    MathFields[FocusedMathFieldId].mf.moveToLeftEnd();
  }

}

function UnfocusMathFields(){
  FocusedMathFieldId = "none";
  SetMathFieldsUI();
}

function FocusOnThisMathField(rid){
  FocusedMathFieldId = rid;
  SetMathFieldsUI();
}

function MoveCursor1Line(id, move = "down", direction = "right"){
  BlurMathFields();
  let nextLineId = undefined;
  if(move == "down"){
    nextLineId = $(`#${id}`).parents(".editor_line").next().find(".my_math_field").attr("id");

    if(nextLineId == undefined){//there is no line below so we must create one
      MathFieldKeyPressEnter($(`#${id}`).parents(".editor_line"), false);
    }
    else{
      FocusedMathFieldId = nextLineId;
      SetMathFieldsUI();
      MathFields[FocusedMathFieldId].mf.focus();
      if(direction == "right"){
        MathFields[FocusedMathFieldId].mf.moveToLeftEnd();
      }
      else{
        MathFields[FocusedMathFieldId].mf.moveToLeftEnd();
      }

    }

  }
  else if(move == "up"){
    nextLineId = $(`#${id}`).parents(".editor_line").prev().find(".my_math_field").attr("id");
    if(nextLineId != undefined){
      FocusedMathFieldId = nextLineId;
      SetMathFieldsUI();
      MathFields[FocusedMathFieldId].mf.focus();
      if(direction == "left"){
        MathFields[FocusedMathFieldId].mf.moveToRightEnd();
      }
      else{
        MathFields[FocusedMathFieldId].mf.moveToLeftEnd();
      }
    }
    else{
      MathFields[FocusedMathFieldId].mf.focus();
    }
  }

}

function UpdateLineLabelHeight(id){
  $(`#${id}`).parents(".editor_line").children(".line_label").css({
    height: $(`#${id}`).parent(".my_math_field_col").css("height")
  });
  RecalculateHeightOfLineEmptySpace();
}

function BlurMathFields(){
  for (let [key, value] of Object.entries(MathFields)) {
    value.mf.blur();
  }
}

function AdjustLineLabelNumber(){
  $(".editor_line").each(function(index){
    $(this).find(".line_label span.line-number").html(index + 1);
  });

  //whenever we are adjust the line number that means the number of lines have change so we need to recalculate the height of the empty space below the lines
  RecalculateHeightOfLineEmptySpace();
}

function RecalculateHeightOfLineEmptySpace(){
  let h = $("#math_field_editor_container").height() - $("#editor_lines_container").height() - 5;
  h = (h < 36) ? 36 : h;
  $("#editor_empty_space_container").css("height",`${h}px`);
}

function CreateFullUnitsString(quantity, name, symbol){
  return `${quantity}: ${name} (${symbol})`;
}

function GenerateAutoCompleteData(){
  let data = {};
  let unitReference = {};
  UnitReference = {};
  for (let [key, value] of Object.entries(ListOfSIUnits)) {
    let k = CreateFullUnitsString(key, value.name, value.symbol);
    data[k] = null;
    value.quantity = key;
    unitReference[k] = value;
  }

  UnitReference = Object.assign({}, unitReference);

  return data;
}

function SetMathFieldsUI(){
  $(".line_label").removeClass('active');
  $(`#${FocusedMathFieldId}`).parents(".editor_line").children(".line_label").addClass("active");
  $(".my_math_field_col").removeClass("active");
  $(`#${FocusedMathFieldId}`).parent(".my_math_field_col").addClass("active");
}

function DeleteCurrentMathFieldAndCopyContentIntoPreviousMathField(id){
  //the id of the mathfield that needs to be focused because this one is getting deleted
  let newId = $(`#${id}`).parents(".editor_line").prev().find(".my_math_field").attr("id");
  if(newId != undefined){
    //setting new mathfield
    FocusedMathFieldId = newId;
    //copying latex string from the line that will be deleted
    let addedLs =  MathFields[id].mf.latex();
    let existingLs = MathFields[FocusedMathFieldId].mf.latex();
    //deleting mathfield
    delete MathFields[id];
    $(`#${id}`).parents(".editor_line").remove();

    EditingMathFields = true;
    MathFields[FocusedMathFieldId].mf.latex(addedLs);
    MathFields[FocusedMathFieldId].mf.moveToLeftEnd();
    UpdateLineLabelHeight(FocusedMathFieldId);
    EditingMathFields = false;
    MathFields[FocusedMathFieldId].mf.write(existingLs);
    MathFields[FocusedMathFieldId].mf.focus();
    SetMathFieldsUI();
    AdjustLineLabelNumber();

  }
}

function ToggleKeyboard(){
  if($("#toggle-dir").hasClass("down-arrow")){
    $("#toggle-dir").removeClass("down-arrow");
    $("#toggle-dir").addClass("up-arrow");
    $("#toggle-dir").html("keyboard_arrow_up");
    $("#keyboard-container").css("bottom","-150px");
  }
  else{
    $("#toggle-dir").removeClass("up-arrow");
    $("#toggle-dir").addClass("down-arrow");
    $("#toggle-dir").html("keyboard_arrow_down");
    $("#keyboard-container").css("bottom","0px");
  }
}

function RenderVariableCollectionErrors(){
  //console.log("RenderVariableCollectionErrors");
  // this function goes through all the objects holding variable data and creates errors and displays them in the ui through tooltips exactly like mathfields
  // the first thing we need to do is create for loops that go through each object that holds variable data
  // next we need to find any errors that exist and format them into an object that the ejs template "mathfield-error" can understand to create a tooltip for the error
  // then we need to figure out which ".variable-collection-error-container" span to attach the tooltip onto

  let errorsInVariableCollection = {};

  for(const [key, value] of Object.entries(DefinedVariables)){
    let errors = [];
    if(value.type == "vector"){
      if(!value.canBeVector){
        errors.push({
          error: {
            type: "This unit can't be a vector",
            description: "This vector has units that can only be mesaured using a scalar"
          },
          latexExpressions: undefined,
        });
      }
      if(value.magnitudeOfVectorEqualsVectorMagnitude == false){
        let vectorMagnitudeLs = RemoveVectorLatexString(key);
        // we have to make sure that the vector magnitude variable doesn't have an empty string, a string filled with spaces, or "undefined" for its value. if it does we just say its equal to 0
        let vectorMagnitudeValue = (DefinedVariables[vectorMagnitudeLs].value.replace(/\\\s|\s*/g,"") == "" || DefinedVariables[vectorMagnitudeLs].value == undefined) ? "0" : DefinedVariables[vectorMagnitudeLs].value;
        errors.push({
          error: {
            type: "Magnitude of vector and vector magnitude don't equal",
            description: "Calculating the magnitude of the vector doesn't evaluate to the value of the vector magnitude variable."
          },
          latexExpressions: [`\\left(\\left|${key}\\right|=${vectorMagnitudeLs}\\right)\\ \\Rightarrow\\ \\left(${value.vectorMagnitude}\\neq ${vectorMagnitudeValue}\\right)`],
        });
      }
    }

    // now that we have possibly populated errors array with data we need to add the errors to the "errorsInVariableCollection" object using the variables ls as the key
    if(errors.length > 0){
      errorsInVariableCollection[key] = {errors: errors, rid: value.rid};
    }
  }

  for(const [key, value] of Object.entries(EL.undefinedVars.undefined)){
    let errors = [];
    if(value.type == "vector"){
      if(!value.canBeVector){
        errors.push({
          error: {
            type: "This unit can't be a vector",
            description: "This vector has units that can only be a mesaured using a scalar"
          },
          latexExpressions: undefined,
        });
      }
      if(value.magnitudeOfVectorEqualsVectorMagnitude == false){
        let vectorMagnitudeLs = RemoveVectorLatexString(key);
        // we have to make sure that the vector magnitude variable doesn't have an empty string, a string filled with spaces, or "undefined" for its value. if it does we just say its equal to 0
        let vectorMagnitudeValue = (EL.undefinedVars.undefined[vectorMagnitudeLs].value.replace(/\\\s|\s*/g,"") == "" || EL.undefinedVars.undefined[vectorMagnitudeLs].value == undefined) ? "0" : EL.undefinedVars.undefined[vectorMagnitudeLs].value;
        errors.push({
          error: {
            type: "Magnitude of vector and vector magnitude don't equal",
            description: "Calculating the magnitude of the vector doesn't evaluate to the value of the vector magnitude variable."
          },
          latexExpressions: [`\\left|${key}\\right|=${vectorMagnitudeLs}\\ \\Rightarrow\\ ${value.vectorMagnitude}\\neq ${vectorMagnitudeValue}`],
        });
      }
    }

    // now that we have possibly populated errors array with data we need to add the errors to the "errorsInVariableCollection" object using the variables ls as the key
    if(errors.length > 0){
      errorsInVariableCollection[key] = {errors: errors, rid: value.rid};
    }
  }

  for(const [key, value] of Object.entries(EL.undefinedVars.defined)){
    let errors = [];
    if(value.type == "vector"){
      if(!value.canBeVector){
        errors.push({
          error: {
            type: "This unit can't be a vector",
            description: "This vector has units that can only be a mesaured using a scalar"
          },
          latexExpressions: undefined,
        });
      }
      if(value.magnitudeOfVectorEqualsVectorMagnitude == false){
        let vectorMagnitudeLs = RemoveVectorLatexString(key);
        // we have to make sure that the vector magnitude variable doesn't have an empty string, a string filled with spaces, or "undefined" for its value. if it does we just say its equal to 0
        let vectorMagnitudeValue = (EL.undefinedVars.defined[vectorMagnitudeLs].value.replace(/\\\s|\s*/g,"") == "" || EL.undefinedVars.defined[vectorMagnitudeLs].value == undefined) ? "0" : EL.undefinedVars.defined[vectorMagnitudeLs].value;
        errors.push({
          error: {
            type: "Magnitude of vector and vector magnitude don't equal",
            description: "Calculating the magnitude of the vector doesn't evaluate to the value of the vector magnitude variable."
          },
          latexExpressions: [`\\left|${key}\\right|=${vectorMagnitudeLs}\\ \\Rightarrow\\ ${value.vectorMagnitude}\\neq ${vectorMagnitudeValue}`],
        });
      }
    }

    // now that we have possibly populated errors array with data we need to add the errors to the "errorsInVariableCollection" object using the variables ls as the key
    if(errors.length > 0){
      errorsInVariableCollection[key] = {errors: errors, rid: value.rid};
    }
  }

  // before we add any errors we need to clear past errors
  $("#my_variables-collection-container .variable-row .variable-collection-error-container").each(function(){
    $(this).removeClass('active');
    // we will try to destroy any tooltip that this "variable-collection-error-container" may have 
    try{
      $(this).tooltip('destroy');
    }catch(err){}
  });


  //console.log("errorsInVariableCollection",errorsInVariableCollection);

  // now that we have collect all possible errors that may exist in the variable collection we need to clear any existing errors that are in the collection and remove class active and destroy any possible tooltips that may exist
  for(const [key, value] of Object.entries(errorsInVariableCollection)){
    // we need to find the correct ".variable-row" to attach the error too
    let variableCollectionErrorContainer = $(`#my_variables-collection-container .variable-row[${IsVariableLatexStringVector(key) ? "vector-rid" : "scalar-rid"}='${value.rid}'] .variable-collection-error-container`);
    //console.log("variableCollectionErrorContainer",variableCollectionErrorContainer);
    //console.log(`#my_variables-collection-container .variable-row[${IsVariableLatexStringVector(key) ? "vector-rid" : "scalar-rid"}='${value.rid}'] .variable-collection-error-container`);
    variableCollectionErrorContainer.addClass('active');// this makes the error bug visible
    variableCollectionErrorContainer.tooltip({html: ejs.render(Templates["mathfield-error"], {errors: value.errors})});

    // now we need to put a hover event that opens the tooltip and renders the latex inside the tooltip
    variableCollectionErrorContainer.hover(function(){
      $(this).tooltip("open");
      $(".log-static-latex").each(function(){
        MQ.StaticMath($(this).get(0)).latex($(this).attr("latex"));
      });
    });
  }

  //after we create the and attached the tooltips we have to initialize the latex inside them into static math field
  
}

function RenderAllMathFieldLogs(){
  for(const [key, value] of Object.entries(MathFields)){
    $(`.line_label > [mf='${key}']`).removeClass('active');
    //removing old tooltips if they exist
    try{
      $(`.line_label > .line-warning[mf='${key}']`).tooltip("destroy");
    }catch(err){
      //they didn't have this specific line and warning tooltipped yet
    }
    try{
      $(`.line_label > .line-error[mf='${key}']`).tooltip("destroy");
    }catch(err){
      //they didn't have this specific line and error tooltipped yet
    }

    if(MathFields[key].log.warning.length > 0){
      $(`.line_label > .line-warning[mf='${key}']`).addClass('active');
      //after we figure what meassage to send we need tooltip the icon with information
      $(`.line_label > .line-warning[mf='${key}']`).tooltip({html: ejs.render(Templates["mathfield-warning"], {warnings: MathFields[key].log.warning})});
      $(`.line_label > .line-warning[mf='${key}']`).hover(function(){
        $(this).tooltip("open");
        $(".log-static-latex").each(function(){
          MQ.StaticMath($(this).get(0)).latex($(this).attr("latex"));
        });
      });
    }
    else if(MathFields[key].log.error.length > 0){
      $(`.line_label > .line-error[mf='${key}']`).addClass('active');
      //after we figure what meassage to send we need tooltip the icon with information
      $(`.line_label > .line-error[mf='${key}']`).tooltip({html: ejs.render(Templates["mathfield-error"], {errors: MathFields[key].log.error})});
      $(`.line_label > .line-error[mf='${key}']`).hover(function(){
        $(this).tooltip("open");
        $(".log-static-latex").each(function(){
          MQ.StaticMath($(this).get(0)).latex($(this).attr("latex"));
        });
      });
    }
    else{
      $(`.line_label > .line-number[mf='${key}']`).addClass('active');
    }
  }

  
}

function GetUndefinedVariables(ls){
  ls = ReplaceCommentsWithSemicolonInLatexString(ls);
  //first we need to get all the variables
  let vars = GetVariablesFromLatexString(ls);
  //console.log("........................vars");
  //console.log(vars);
  let definedVars = Object.keys(DefinedVariables).concat(Object.keys(PreDefinedVariables));
  //console.log("........................definedVars");
  //console.log(definedVars);
  let undefinedVars = [];
  for(var i = 0; i < vars.length; i++){
    if(!definedVars.includes(vars[i])){
      undefinedVars.push(vars[i]);
    }
  }

  //so now we have this list of undefined variables but we need to check if we can automatically assign values to some of the variables using the SimilarDefinedVariables object
  //if we can then they are no longer undefined
  let newSetOfUndefinedVars = TryToAssignDefinitionsToUndefinedVariables(undefinedVars)

  return newSetOfUndefinedVars;

}

function TryToAssignDefinitionsToUndefinedVariables(undefinedVars){
  let keys = Object.keys(SimilarDefinedVariables);
  let newSetOfUndefinedVars = [];
  for(var i = 0; i < undefinedVars.length; i++){
    let ls = undefinedVars[i];
    let foundDefinitionForVariable = false;//keeps track of wheter we we able to get a defintion for the undefined variable

    //before we try to use SimilarDefinedVariables (Imported Variables) to define this undefined variable we will see if there is a vector or vector magnitude counter part for this latex string that is defined.
    //for example if this variable is "F" and we find a variable "\\vec{F}" that is defined for vise versa then we can say we found a definition for this undefined variable

    if(!IsVariableLatexStringVector(ls)){// there is a case where a variable is not a vector and it is undefined but we will see if we can find its vector counterpart and see if its vector counterpart is defined. If its vector counterpart is defined then we will add the vector magnitude which is the undefined variable we are currently parsing to where the vector is. It can be in either EL.undefinedvars.defined or DefinedVariables. 
      // if the latex string is not a vector then we will go and try to find the latex string vector counter part 
      if(DefinedVariables[`\\vec{${ls}}`] != undefined){
        foundDefinitionForVariable = true;
        // that means that this undefined vector magnitude has a defined vector counter part so we will transfer the units data from the vector to the vector magnitude
        // we copy all the data using JSON.parse and stringify and then we reassign specific values of the data to match the state of the undefined variable
        let props = Object.assign(JSON.parse(JSON.stringify(DefinedVariables[`\\vec{${ls}}`])), {
          type: "scalar",//we are using a vector to define its vector magnitude variable ls
          value: undefined,
          rid:  RID(),
          components: undefined, // a scalar shouldn't have components
        });

        UpdateDefinedVariables({
          updateErrorMessages: false,
          type: "update",
          ls: ls,
          editable: true,
          props: props,//seeding it with base information about a variable for example F_{0} that was seen as a force so a similar variable F_{1} should also be seen as a force
          autoGenerated: true,// setting this variable equal to autogenerated because the user didn't define this undefined variable we did so if the user stops using the variable in their work it should just go away
        });

        UpdateMyVariablesCollection({update: true});

      }else if(EL.undefinedVars.defined[`\\vec{${ls}}`] != undefined){
        foundDefinitionForVariable = true;
        // that means that this undefined vector magnitude has a defined vector counter part so we will transfer the units data from the vector to the vector magnitude
        // we copy all the data using JSON.parse and stringify
        let props = JSON.parse(JSON.stringify(EL.undefinedVars.defined[`\\vec{${ls}}`]));

        EL.recordDefinitionForUndefinedVariable(ls, props.unitsMathjs, props.state, props.currentState);
        
        UpdateMyVariablesCollection({update: true});

      }
    }else{
      // if the latex string is not a vector then we will go and try to find the latex string vector counter part 
      if(DefinedVariables[RemoveVectorLatexString(ls)] != undefined){
        foundDefinitionForVariable = true;
        // that means that this undefined vector magnitude has a defined vector counter part so we will transfer the units data from the vector to the vector magnitude
        // we copy all the data using JSON.parse and stringify and then we reassign specific values of the data to match the state of the undefined variable
        let props = Object.assign(JSON.parse(JSON.stringify(DefinedVariables[RemoveVectorLatexString(ls)])), {
          type: "vector",//we are using a vector magnitude to define the vector
          value: undefined,
          state: "unknown",
          currentState: "unknown",
          rid:  RID(),
        });

        UpdateDefinedVariables({
          updateErrorMessages: false,
          type: "update",
          ls: ls,
          editable: true,
          props: props,//seeding it with base information about a variable for example F_{0} that was seen as a force so a similar variable F_{1} should also be seen as a force
          autoGenerated: true,// setting this variable equal to autogenerated because the user didn't define this undefined variable we did so if the user stops using the variable in their work it should just go away
        });

        UpdateMyVariablesCollection({update: true});

      }else if(EL.undefinedVars.defined[RemoveVectorLatexString(ls)] != undefined){
        foundDefinitionForVariable = true;
        // that means that this undefined vector magnitude has a defined vector counter part so we will transfer the units data from the vector to the vector magnitude
        // we copy all the data using JSON.parse and stringify
        let props = JSON.parse(JSON.stringify(EL.undefinedVars.defined[RemoveVectorLatexString(ls)]));

        EL.recordDefinitionForUndefinedVariable(ls, props.unitsMathjs);
        
        UpdateMyVariablesCollection({update: true});

      }
    }


    if(!foundDefinitionForVariable){
      let uv = ls.replace(/_\{[^\}\{\s]*\}/g,"").replace(/'/g,"");//removing underscores to make it more generic to see if it can match with any of the generic variables that are in SimilarDefinedVariables
      uv = RemoveBarAndOverlineFromLatexString(uv);
      let index = keys.indexOf(uv);
      if(index != -1){//we found a match
        foundDefinitionForVariable = true;
        //so now we will define this variable that was before seen as undefined by seeding with the information found in SimilarDefinedVariables object

        UpdateDefinedVariables({
          updateErrorMessages: false,
          type: "update",
          ls: ls,
          editable: true,
          props: Object.assign({},SimilarDefinedVariables[keys[index]]),//seeding it with base information about a variable for example F_{0} that was seen as a force so a similar variable F_{1} should also be seen as a force
          autoGenerated: true,
        });
        UpdateMyVariablesCollection({update: true});
      }
      else if(uv.indexOf("\\dot{") == 0){//checking if this variable is a \\dot{...}

        uv = uv.substring("\\dot{".length, uv.length-1);
        index = keys.indexOf(uv);
        if(index != -1){
          foundDefinitionForVariable = true;
          //now we are trying to figure out the units of the variable inside the \\dot{} operator so that we can divided them by time and see what new quantity emerges and try to get data for that quantity
          let obj = GetFullUnitsStringFromUnitsMathJs(math.evaluate(`${SimilarDefinedVariables[keys[index]].unitsMathjs} * 1 / s`).toString());
          let props = {};
          if(obj.custom){
            props = Object.assign(JSON.parse(JSON.stringify(SimilarDefinedVariables[keys[index]])),{
              unitsMathjs: obj.unitsMathjs,
              unitsLatex: nerdamer.convertToLaTeX(obj.units).toString(),//if it is a custom unit then we have to generate the unit latex from the "units" value in obj
              units: obj.units,
              quantity: "custom",
            });
          }
          else{
            props = Object.assign(JSON.parse(JSON.stringify(SimilarDefinedVariables[keys[index]])),{
              unitsMathjs: obj.unitsMathjs,
              unitsLatex: obj.unitsLatex, 
              units: obj.units,
              quantity: obj.quantity,
            });
          }
          UpdateDefinedVariables({
            updateErrorMessages: false,
            type: "update",
            ls: ls,
            editable: true,
            props: props,//seeding it with base information about a variable for example F_{0} that was seen as a force so a similar variable F_{1} should also be seen as a force
            autoGenerated: true,
          });
          UpdateMyVariablesCollection({update: true});
        }
      }
    }
    

    if(!foundDefinitionForVariable){
      newSetOfUndefinedVars.push(ls);
    }
  }

  return newSetOfUndefinedVars;
}

function ReplaceCommentsWithSemicolonInLatexString(ls){
  //we need to find the index of "\text{" in the string and find the closing bracket and remove everthing in between
  while(ls.indexOf("\\text{") != -1){
    let startIndex = ls.indexOf("\\text{");
    let i = startIndex;
    let foundClosingBracket = false;
    while(i < ls.length){
      if(ls[i] == "}"){
        //we need to check that it is not an escaped closing bracket meaning that it is just text and not a latex closing bracket
        if(ls[i - 1] != "\\"){
          foundClosingBracket = true;
          break;
        }
      }
      i++;
    }

    ls = `${ls.substring(0, startIndex)} ; ${ls.substring(i + 1)}`;
  }

  return ls;
}

function PutBracketsAroundAllSubsSupsAndRemoveEmptySubsSups(ls){
  //puts brackets around all superscripts and subscripts if they don't have them already
  let i = 0;
  let foundIndicator = false;
  while(i < ls.length){
    if(foundIndicator){
      if(ls[i] != "{"){
        ls = ls.substring(0,i) + "{" + ls[i] + "}" + ls.substring(i+1);
      }
    }

    foundIndicator = (ls[i] == "_" || ls[i] == "^");

    i++;
  }

  ls = ls.replace(/_\{(\s|\\)*}/g," ");//remnoving all empty subscripts from latex string
  ls = ls.replace(/\^\{(\s|\\)*}/g," ");//remnoving all empty superscripts from latex string
  return ls;
}

function AddLineLabelHoverEvent(id){
  $(`.line_label [mf='${id}']`).hover(function(){
    OpenLineMessageBox(id);
  },function(){
    CloseLineMessageBox();
  });
}

function OpenLineMessageBox(id){

  //console.log("OpenLineMessageBox.................");
  $("#line-message-box-question, #line-message-box-warning, #line-message-box-error").removeClass("active");

  if(MathFields[id].message.question != null){
    $("#line-message-box-question").addClass('active');
  }
  else if(MathFields[id].message.warning != null){
    $("#line-message-box-warning").addClass('active');
    if(MathFields[id].message.warning.type == 1){
      MessageBoxMathFields.warning.m1.latex(MathFields[id].message.warning.vars.join(","));
    }
  }
  else if(MathFields[id].message.error != null){
    $("#line-message-box-error").addClass('active');
    if(MathFields[id].message.error.type == 1){
      $("#line-message-box-error").html("click to view error in log");
    }
  }

  //after setting up the message box we need to display it in the right place
  let r = $(`#${id}`).parents(".editor_line").find(".line_label")[0].getBoundingClientRect();
  $("#line-message-box").css({
    top: r.top + r.height + 10,
    left: 10
  });

  $("#line-message-box").css("display","block");

}

function CloseLineMessageBox(){
  $("#line-message-box").css("display","none");
}

function CheckIfPhysicsConstantCheckboxIsDisabled(el){
  //we need to check if variable is being used in the editor and if it is this can't be removed
  if(el.prev().attr("disabled") == "disabled"){
    M.toast({html: "This variable can't be removed because it is being used", displayLength: 3000});
  }
}

function TogglePhysicsConstant(el, index){
    let obj = Object.assign({}, ListOfPhysicsConstants[index]);
    if(el.prop("checked")){
      M.toast({html: `<span class='green-text text-lighten-4'>${obj.quantityDescription}</span> &nbsp; added to 'My Variables' Tab`, displayLength: 3000});
      UpdateMyVariablesCollection({ls: obj.symbol, rid: el.attr("rid"), add: true, pc: obj, editable: false});
      DisablePhysicsConstantCheckboxesThatAreBeingUsed();
    }
    else{
      M.toast({html: `<span class='red-text text-lighten-4'>${obj.quantityDescription}</span> 	&nbsp; removed from 'My Variables' Tab`, displayLength: 3000});
      UpdateMyVariablesCollection({ls: obj.symbol, rid: el.attr("rid"), remove: true, editable: false});
    }
}

function GetDefinedPhysicsConstants(){
  let vars = [];
  for(const [key, value] of Object.entries(PreDefinedVariables)){
    if(value.type == "physics constant"){
      vars.push(key);
    }
  }
  return vars;
}

function OrderCompileAndRenderMyVariablesCollection(){
  //ORDER
  //get all the variables we need
  let trulyUndefinedVars = Object.keys(EL.undefinedVars.undefined);
  let orderedTrulyUndefinedVars = [];
  let definedVars = GetDefinedPhysicsConstants().concat(Object.keys(DefinedVariables)).concat(Object.keys(EL.undefinedVars.defined));

  let orderedDefinedVars = [];
  //now we have to order them by when they show up in the editor
  let orderedIds = OrderMathFieldIdsByLineNumber(Object.keys(MathFields));
  for(const [lineNumber, id] of Object.entries(orderedIds)){
    //before we do anything there are some edge case we need to take care of specifically \nabla^2 need to be formatted as \nabla \cdot \nabla
    let variables = GetVariablesFromLatexString(MathFields[id].mf.latex());
    for(var i = 0; i < variables.length; i++){
      let index = trulyUndefinedVars.indexOf(variables[i]);
      if(index != -1){
        orderedTrulyUndefinedVars.push(variables[i]);
        trulyUndefinedVars.splice(index,1);//remove it form array because we have accounted for it in the ordered list
      }
      else{
        index = definedVars.indexOf(variables[i]);
        if(index != -1){
          orderedDefinedVars.push(variables[i]);
          definedVars.splice(index,1);//remove it form array because we have accounted for it in the ordered list
        }
      }

    }
  }

  //if there is anything left in the unorded arrays then just append it to the ordered lists
  orderedTrulyUndefinedVars = orderedTrulyUndefinedVars.concat(trulyUndefinedVars);//trulyUndefinedVars should be empty because all of the undefined variables should appear somewhere in the editor and shouldn't be unused
  orderedDefinedVars = orderedDefinedVars.concat(definedVars);
  let unusedDefinedVars = [].concat(definedVars);

  //before we compile and render these list of undefined and defined variables we want to pair up vectors with vector magnitudes so that we can display them slightly different then just a lone vector or scalar variable
  
  //Creating pairs for undefined variables
  for(let i = 0; i < orderedTrulyUndefinedVars.length; i++){
    let index;
    if(IsVariableLatexStringVector(orderedTrulyUndefinedVars[i])){
      // if the variable stirng is a vector then we will look at all the other indexes and see if we can find a vector magnitude of this variable
      let vectorMagnitudeLs = RemoveVectorLatexString(orderedTrulyUndefinedVars[i]);
      index = orderedTrulyUndefinedVars.indexOf(vectorMagnitudeLs);
      if(index != -1){
        //changing this index to equal an object and not a string which holds data about a vector and its magnitude
        orderedTrulyUndefinedVars[i] = {
          vectorMagnitudeLs: vectorMagnitudeLs, 
          vectorLs: orderedTrulyUndefinedVars[i],
        }
        //after we store the vector magnitude value we need to remove it from the array because we have already accountted for it
        orderedTrulyUndefinedVars.splice(index, 1);// we don't have to worry about a shift in the "orderedTrulyUndefinedVars" array because all the indexes we are taking out will always be greater than the current index "i" we are at
      } 
    }else{
      // if the variable is not a vector then we need to try to look for the variables vector counter part 
      let vectorLs = `\\vec{${orderedTrulyUndefinedVars[i]}}`;
      index = orderedTrulyUndefinedVars.indexOf(vectorLs);
      if(index != -1){
        //changing this index to equal an object and not a string which holds data about a vector and its magnitude
        orderedTrulyUndefinedVars[i] = {
          vectorMagnitudeLs: orderedTrulyUndefinedVars[i], 
          vectorLs: vectorLs,
        }
        //after we store the vector counter part of this vector magnitude we need to remove it from the array because we have already accountted for it
        orderedTrulyUndefinedVars.splice(index, 1);// we don't have to worry about a shift in the "orderedTrulyUndefinedVars" array because all the indexes we are taking out will always be greater than the current index "i" we are at
      }
    }
  }

  //Creating pairs for defined variables
  for(let i = 0; i < orderedDefinedVars.length; i++){
    let index;
    if(IsVariableLatexStringVector(orderedDefinedVars[i])){
      // if the variable stirng is a vector then we will look at all the other indexes and see if we can find a vector magnitude of this variable
      let vectorMagnitudeLs = RemoveVectorLatexString(orderedDefinedVars[i]);
      index = orderedDefinedVars.indexOf(vectorMagnitudeLs);
      if(index != -1){
        //changing this index to equal an object and not a string which holds data about a vector and its magnitude
        orderedDefinedVars[i] = {
          vectorMagnitudeLs: vectorMagnitudeLs, 
          vectorLs: orderedDefinedVars[i],
        }
        //after we store the vector magnitude value we need to remove it from the array because we have already accountted for it
        orderedDefinedVars.splice(index, 1);// we don't have to worry about a shift in the "orderedTrulyUndefinedVars" array because all the indexes we are taking out will always be greater than the current index "i" we are at
      } 
    }else{
      // if the variable is not a vector then we need to try to look for the variables vector counter part 
      let vectorLs = `\\vec{${orderedDefinedVars[i]}}`;
      index = orderedDefinedVars.indexOf(vectorLs);
      if(index != -1){
        //changing this index to equal an object and not a string which holds data about a vector and its magnitude
        orderedDefinedVars[i] = {
          vectorMagnitudeLs: orderedDefinedVars[i], 
          vectorLs: vectorLs,
        }
        //after we store the vector counter part of this vector magnitude we need to remove it from the array because we have already accountted for it
        orderedDefinedVars.splice(index, 1);// we don't have to worry about a shift in the "orderedTrulyUndefinedVars" array because all the indexes we are taking out will always be greater than the current index "i" we are at
      }
    }
  }

  //COMPILE
  html = "";
  for(var i = 0; i < orderedTrulyUndefinedVars.length; i++){
    let opts = {};

    if(typeof(orderedTrulyUndefinedVars[i]) == "object"){
      opts = {
        vectorLs: orderedTrulyUndefinedVars[i].vectorLs,
        variableVector: Object.assign({}, EL.undefinedVars.undefined[orderedTrulyUndefinedVars[i].vectorLs]),
        vectorMagnitudeLs: orderedTrulyUndefinedVars[i].vectorMagnitudeLs,
        variableVectorMagnitude: Object.assign({}, EL.undefinedVars.undefined[orderedTrulyUndefinedVars[i].vectorMagnitudeLs]),
        unused: false,
      }

      // render a pair of variables: vector and its vector magintude
      html += ejs.render(Templates["VariableCollection"]["undefined-variable-pair"], {opts: opts});

    }else{
      opts = {
        ls: orderedTrulyUndefinedVars[i],
        variable: Object.assign({}, EL.undefinedVars.undefined[orderedTrulyUndefinedVars[i]]),
        unused: false,
      }

      html += ejs.render(Templates["VariableCollection"]["undefined-variable"], {opts: opts});
    }
    
  }

  for(var i = 0; i < orderedDefinedVars.length; i++){

    let opts = {};

    if(typeof(orderedDefinedVars[i]) == "object"){
      opts = {
        vectorLs: orderedDefinedVars[i].vectorLs,
        variableVector: GetStoredVariableInfo(orderedDefinedVars[i].vectorLs),
        vectorMagnitudeLs: orderedDefinedVars[i].vectorMagnitudeLs,
        variableVectorMagnitude: GetStoredVariableInfo(orderedDefinedVars[i].vectorMagnitudeLs),
        unused: unusedDefinedVars.includes(orderedDefinedVars[i].vectorLs) && unusedDefinedVars.includes(orderedDefinedVars[i].vectorMagnitudeLs),// if both the vector and its vector magnitude are both unused then we can return true for unused
      };

      html += ejs.render(Templates["VariableCollection"]["defined-variable-pair"], {opts: opts});

    }else{
      opts = {
        ls: orderedDefinedVars[i],
        variable: GetStoredVariableInfo(orderedDefinedVars[i]),
        unused: unusedDefinedVars.includes(orderedDefinedVars[i]),
      };

      if(DefinedVariables[orderedDefinedVars[i]] != undefined || EL.undefinedVars.defined[orderedDefinedVars[i]] != undefined){
        html += ejs.render(Templates["VariableCollection"]["defined-variable"], {opts: opts});
      }else if(PreDefinedVariables[orderedDefinedVars[i]] != undefined){
        html += ejs.render(Templates["VariableCollection"]["physics-constant"], {opts: opts});
      }
    }

  }

  //RENDER
  if(html == ""){//if there are no variables defined we will just show a nice message to the user so they know whats up
    html = ejs.render(Templates["no-variables-defined"]);
  }

  //we need to remove all tooltips in the collection before we create new ones
  $('#my_variables-collection-container .tooltipped, #my_variables-collection-container .variable-collection-error-container.active').each(function(){
    try{
      $(this).tooltip("destroy");
    }catch(err){}
  });
  
  
  $("#my_variables-collection-container .my-collection").html(html);//rendering new collection
  //Add event listeners and initialize static math fields
  $("#my_variables .my-collection span").each(function(){
    if($(this).attr("rid") != undefined && $(this).attr("latex") != undefined){
      MQ.StaticMath($(this).get(0)).latex($(this).attr("latex"));
    }
  });

  $(".variable-value").each(function(){
    let opts = {
      spaceBehavesLikeTab: false,
      restrictMismatchedBrackets: true,
      sumStartsWithNEquals: true,
      supSubsRequireOperand: true,
      autoCommands: `sqrt pi`,
      autoOperatorNames: 'sin cos csc sec tan arcsin arccos cot sinh cosh tanh log ln',
      charsThatBreakOutOfSupSub: '+-=<>',
      handlers: {
        edit: function(mathField) {
          // it seems like the "edit" event listener  is triggered when the mathField is initialized which happens every time the my
          // variables collection is update. We don't consider this an edit so the below if statements are checking if the "edit" was
          // triggered because of an initialization or because the user actually changed something


          let valueFormattingError = FindFormattingErrorInVariableValueMathField(mathField.latex(), $(mathField.el()).attr("type"));
          $(`.variable-value[rid='${$(mathField.el()).attr("rid")}']`).removeClass("error");
          try{//the input field may not have a tooltip connected to it so this line may not work
            $(`.variable-value[rid='${$(mathField.el()).attr("rid")}']`).tooltip("destroy");
          }catch(err){}
          if(valueFormattingError != undefined){
            //we found an error so we need to display it as a tooltip
            $(`.variable-value[rid='${$(mathField.el()).attr("rid")}']`).addClass("error");
            $(`.variable-value[rid='${$(mathField.el()).attr("rid")}']`).attr("data-tooltip",valueFormattingError);
            $(`.variable-value[rid='${$(mathField.el()).attr("rid")}']`).tooltip();
            $(`.variable-value[rid='${$(mathField.el()).attr("rid")}']`).tooltip("open");
          }else{
            //if there are no formatting errors in the text then we can show the default tooltip
            /*
            $(`.variable-value[rid='${$(mathField.el()).attr("rid")}']`).attr("data-tooltip","Edit value and press enter to update editor");
            $(`.variable-value[rid='${$(mathField.el()).attr("rid")}']`).tooltip();
            $(`.variable-value[rid='${$(mathField.el()).attr("rid")}']`).tooltip("open");
            */
          }
          FindAndUpdateVariableByRID({rid: $(mathField.el()).attr("rid"), value: mathField.latex(), valueFormattingError: valueFormattingError, type: $(mathField.el()).attr("type") });
        },
        enter: function(){
          DisplayLoadingBar(true);
          ExecutionID = RID();
          (debounce(function(executionID){
            if(executionID == ExecutionID){
              //console.log("currently parsing", EL.currentlyParsing);
              EL.GenerateEditorErrorMessages();
              DisplayLoadingBar(false);
            }
            
          }, 100))(ExecutionID);
        },
      }
    };
    
    if($(this).hasClass("static-mathfield")){
      //this means we are displaying a variable value for a known variable meaning the value shouldn't be able to be edited because the value was generated by the program
      MQ.StaticMath($(this).get(0)).latex($(this).attr("latex"));
    }
    else{
      let mf;
      if($(this).attr("latex") == ""){// if the latex equals nothing then all we have to do is initialize the mathField  
        // for some reason this element has html inside of it eventhough we haven't created the mathfield so we are removing any html before we initialize the math field
        $(this).html("");
        mf = MQ.MathField($(this).get(0), opts);
        //console.log("mf.latex()",mf.latex())
      }else{// if the latex attribute actually equals something then we need to initialize the mathfield with its correct latex information
        mf = MQ.MathField($(this).get(0), opts).latex($(this).attr("latex"));
      }

      if(LastVariableRIDChangedToGiven == $(this).attr("rid")){
        mf.focus();
      }

      
      
    }
    
    
  });
  //tooltipping everything that was just created and needs a tooltip
  $("#my_variables .tooltipped").tooltip();

  //updating hover event
  $("#my_variables .variable-row").unbind("mouseout mouseover");
  $("#my_variables .variable-row").hover(function(){
    $("#my_variables .variable-row").removeClass('active');
    $(this).addClass('active');
  },function(){
    $(this).removeClass('active');
  });
  //checking how many variables are defined and if there are none adding the no-variables-defined class to the collection
  //this helps with ui look and feel
  if($("#my_variables .variable-row").length == 0){
    $("#my_variables .my-collection").addClass("no-variables-defined");
  }
  else{
    $("#my_variables .my-collection").removeClass("no-variables-defined");
  }

}


function OrderCompileAndUpdateMyVariablesCollection(updatedVariableInfo = undefined){
  
  // this function is an exact copy of "OrderCompileAndRenderMyVariablesCollection" except instead of clearing everything and rendering the variable collection
  // from scratch this function re renders all the variables except the variable that the user is current updating because we don't want to mess with their
  // typing in the ".variable-value" mathfield
  if(updatedVariableInfo == undefined){return;}
  //console.log("updatedVariableInfo",updatedVariableInfo);
  if(updatedVariableInfo.ls == undefined || updatedVariableInfo.rid == undefined){return;}
  //ORDER
  //get all the variables we need
  let trulyUndefinedVars = Object.keys(EL.undefinedVars.undefined);
  let orderedTrulyUndefinedVars = [];
  let definedVars = GetDefinedPhysicsConstants().concat(Object.keys(DefinedVariables)).concat(Object.keys(EL.undefinedVars.defined));

  let orderedDefinedVars = [];
  //now we have to order them by when they show up in the editor
  let orderedIds = OrderMathFieldIdsByLineNumber(Object.keys(MathFields));
  for(const [lineNumber, id] of Object.entries(orderedIds)){
    //before we do anything there are some edge case we need to take care of specifically \nabla^2 need to be formatted as \nabla \cdot \nabla
    let variables = GetVariablesFromLatexString(MathFields[id].mf.latex());
    for(var i = 0; i < variables.length; i++){
      let index = trulyUndefinedVars.indexOf(variables[i]);
      if(index != -1){
        orderedTrulyUndefinedVars.push(variables[i]);
        trulyUndefinedVars.splice(index,1);//remove it form array because we have accounted for it in the ordered list
      }
      else{
        index = definedVars.indexOf(variables[i]);
        if(index != -1){
          orderedDefinedVars.push(variables[i]);
          definedVars.splice(index,1);//remove it form array because we have accounted for it in the ordered list
        }
      }

    }
  }

  //if there is anything left in the unorded arrays then just append it to the ordered lists
  orderedTrulyUndefinedVars = orderedTrulyUndefinedVars.concat(trulyUndefinedVars);//trulyUndefinedVars should be empty because all of the undefined variables should appear somewhere in the editor and shouldn't be unused
  orderedDefinedVars = orderedDefinedVars.concat(definedVars);
  let unusedDefinedVars = [].concat(definedVars);

  //before we compile and render these list of undefined and defined variables we want to pair up vectors with vector magnitudes so that we can display them slightly different then just a lone vector or scalar variable
  
  //Creating pairs for undefined variables
  for(let i = 0; i < orderedTrulyUndefinedVars.length; i++){
    let index;
    if(IsVariableLatexStringVector(orderedTrulyUndefinedVars[i])){
      // if the variable stirng is a vector then we will look at all the other indexes and see if we can find a vector magnitude of this variable
      let vectorMagnitudeLs = RemoveVectorLatexString(orderedTrulyUndefinedVars[i]);
      index = orderedTrulyUndefinedVars.indexOf(vectorMagnitudeLs);
      if(index != -1){
        //changing this index to equal an object and not a string which holds data about a vector and its magnitude
        orderedTrulyUndefinedVars[i] = {
          vectorMagnitudeLs: vectorMagnitudeLs, 
          vectorLs: orderedTrulyUndefinedVars[i],
        }
        //after we store the vector magnitude value we need to remove it from the array because we have already accountted for it
        orderedTrulyUndefinedVars.splice(index, 1);// we don't have to worry about a shift in the "orderedTrulyUndefinedVars" array because all the indexes we are taking out will always be greater than the current index "i" we are at
      } 
    }else{
      // if the variable is not a vector then we need to try to look for the variables vector counter part 
      let vectorLs = `\\vec{${orderedTrulyUndefinedVars[i]}}`;
      index = orderedTrulyUndefinedVars.indexOf(vectorLs);
      if(index != -1){
        //changing this index to equal an object and not a string which holds data about a vector and its magnitude
        orderedTrulyUndefinedVars[i] = {
          vectorMagnitudeLs: orderedTrulyUndefinedVars[i], 
          vectorLs: vectorLs,
        }
        //after we store the vector counter part of this vector magnitude we need to remove it from the array because we have already accountted for it
        orderedTrulyUndefinedVars.splice(index, 1);// we don't have to worry about a shift in the "orderedTrulyUndefinedVars" array because all the indexes we are taking out will always be greater than the current index "i" we are at
      }
    }
  }

  //Creating pairs for defined variables
  for(let i = 0; i < orderedDefinedVars.length; i++){
    let index;
    if(IsVariableLatexStringVector(orderedDefinedVars[i])){
      // if the variable stirng is a vector then we will look at all the other indexes and see if we can find a vector magnitude of this variable
      let vectorMagnitudeLs = RemoveVectorLatexString(orderedDefinedVars[i]);
      index = orderedDefinedVars.indexOf(vectorMagnitudeLs);
      if(index != -1){
        //changing this index to equal an object and not a string which holds data about a vector and its magnitude
        orderedDefinedVars[i] = {
          vectorMagnitudeLs: vectorMagnitudeLs, 
          vectorLs: orderedDefinedVars[i],
        }
        //after we store the vector magnitude value we need to remove it from the array because we have already accountted for it
        orderedDefinedVars.splice(index, 1);// we don't have to worry about a shift in the "orderedTrulyUndefinedVars" array because all the indexes we are taking out will always be greater than the current index "i" we are at
      } 
    }else{
      // if the variable is not a vector then we need to try to look for the variables vector counter part 
      let vectorLs = `\\vec{${orderedDefinedVars[i]}}`;
      index = orderedDefinedVars.indexOf(vectorLs);
      if(index != -1){
        //changing this index to equal an object and not a string which holds data about a vector and its magnitude
        orderedDefinedVars[i] = {
          vectorMagnitudeLs: orderedDefinedVars[i], 
          vectorLs: vectorLs,
        }
        //after we store the vector counter part of this vector magnitude we need to remove it from the array because we have already accountted for it
        orderedDefinedVars.splice(index, 1);// we don't have to worry about a shift in the "orderedTrulyUndefinedVars" array because all the indexes we are taking out will always be greater than the current index "i" we are at
      }
    }
  }

  //COMPILE
  html = "";
  for(var i = 0; i < orderedTrulyUndefinedVars.length; i++){
    let opts = {};

    if(typeof(orderedTrulyUndefinedVars[i]) == "object"){
      opts = {
        vectorLs: orderedTrulyUndefinedVars[i].vectorLs,
        variableVector: Object.assign({}, EL.undefinedVars.undefined[orderedTrulyUndefinedVars[i].vectorLs]),
        vectorMagnitudeLs: orderedTrulyUndefinedVars[i].vectorMagnitudeLs,
        variableVectorMagnitude: Object.assign({}, EL.undefinedVars.undefined[orderedTrulyUndefinedVars[i].vectorMagnitudeLs]),
        unused: false,
      }

      // render a pair of variables: vector and its vector magintude
      html += ejs.render(Templates["VariableCollection"]["undefined-variable-pair"], {opts: opts});

    }else{
      opts = {
        ls: orderedTrulyUndefinedVars[i],
        variable: Object.assign({}, EL.undefinedVars.undefined[orderedTrulyUndefinedVars[i]]),
        unused: false,
      }

      html += ejs.render(Templates["VariableCollection"]["undefined-variable"], {opts: opts});
    }
    
  }

  for(var i = 0; i < orderedDefinedVars.length; i++){

    let opts = {};

    if(typeof(orderedDefinedVars[i]) == "object"){
      opts = {
        vectorLs: orderedDefinedVars[i].vectorLs,
        variableVector: GetStoredVariableInfo(orderedDefinedVars[i].vectorLs),
        vectorMagnitudeLs: orderedDefinedVars[i].vectorMagnitudeLs,
        variableVectorMagnitude: GetStoredVariableInfo(orderedDefinedVars[i].vectorMagnitudeLs),
        unused: unusedDefinedVars.includes(orderedDefinedVars[i].vectorLs) && unusedDefinedVars.includes(orderedDefinedVars[i].vectorMagnitudeLs),// if both the vector and its vector magnitude are both unused then we can return true for unused
      };

      html += ejs.render(Templates["VariableCollection"]["defined-variable-pair"], {opts: opts});

    }else{
      opts = {
        ls: orderedDefinedVars[i],
        variable: GetStoredVariableInfo(orderedDefinedVars[i]),
        unused: unusedDefinedVars.includes(orderedDefinedVars[i]),
      };

      if(DefinedVariables[orderedDefinedVars[i]] != undefined || EL.undefinedVars.defined[orderedDefinedVars[i]] != undefined){
        html += ejs.render(Templates["VariableCollection"]["defined-variable"], {opts: opts});
      }else if(PreDefinedVariables[orderedDefinedVars[i]] != undefined){
        html += ejs.render(Templates["VariableCollection"]["physics-constant"], {opts: opts});
      }
    }

  }

  //RENDER

  // first thing we need to do is figure out all the html that should come before the variable the user is trying to update and all the html that comes after the variable the user is trying to update
  let container = $("<div>").append(html);
  let variableRIDAttribute = IsVariableLatexStringVector(updatedVariableInfo.ls) ? "vector-rid" : "scalar-rid";
  // now we have to go through this jquery dom element and figure out the html that comes before and after
  let collectionHTML = {
    before: "",
    after: "",
    currentVariableBeingUpdated: undefined,
  }
  let beforeVariable = true;
  container.children(".variable-row").each(function(){
    if($(this).attr(variableRIDAttribute) == updatedVariableInfo.rid){
      collectionHTML.currentVariableBeingUpdated = $(this).clone();
      beforeVariable = false;
    }else{
      // we are adding the variabl-row html to the collectionHTML object
      let htmlToAdd = $('<div>').append($(this).clone()).html();// this line doens't just get the inner html but all so the information inside the ".variabl-row" html tag
      if(beforeVariable){
        collectionHTML.before += htmlToAdd;
      }else{
        collectionHTML.after += htmlToAdd;
      }
    }
  });

  // before we remove "variable-row" that we want to update we have to destroy any tooltips that these dom elements may have
  //we need to remove all tooltips in the collection before we create new ones
  $('#my_variables-collection-container .tooltipped, #my_variables-collection-container .variable-collection-error-container.active').each(function(){
    if($(this).parents(".variable-row").attr(variableRIDAttribute) != updatedVariableInfo.rid){
      try{
        $(this).tooltip("destroy");
      }catch(err){}
    }
  });

  // now that we have the html that goes before and after the variable the user is updating we need to remove everything that is currently before and after this variable
  $('#my_variables-collection-container .variable-row').each(function(){
    if($(this).attr(variableRIDAttribute) != updatedVariableInfo.rid){
      // this means that this "variable-row" is not the one the user is editing so we need to remove it
      $(this).remove();
    }
  });

  // now that we have removed everything before and after the variable we need to add variable rows before and after the variable the user is updating
  $('#my_variables-collection-container .my-collection').prepend(collectionHTML.before);
  $('#my_variables-collection-container .my-collection').append(collectionHTML.after);

  
  //Add event listeners and initialize static math fields
  $("#my_variables .my-collection span").each(function(){
    // we should only create new static mathfields for ".variable-row" that is not the one that the user is updating at the moment
    if($(this).parents(".variable-row").attr(variableRIDAttribute) != updatedVariableInfo.rid){
      if($(this).attr("rid") != undefined && $(this).attr("latex") != undefined){
        MQ.StaticMath($(this).get(0)).latex($(this).attr("latex"));
      }
    }
  });

  $(".variable-value").each(function(){
    if($(this).parents(".variable-row").attr(variableRIDAttribute) != updatedVariableInfo.rid){
      let opts = {
        spaceBehavesLikeTab: false,
        restrictMismatchedBrackets: true,
        sumStartsWithNEquals: true,
        supSubsRequireOperand: true,
        autoCommands: `sqrt pi`,
        autoOperatorNames: 'sin cos csc sec tan arcsin arccos cot sinh cosh tanh log ln',
        charsThatBreakOutOfSupSub: '+-=<>',
        handlers: {
          edit: function(mathField) {
            // it seems like the "edit" event listener  is triggered when the mathField is initialized which happens every time the my
            // variables collection is update. We don't consider this an edit so the below if statements are checking if the "edit" was
            // triggered because of an initialization or because the user actually changed something
  
  
            let valueFormattingError = FindFormattingErrorInVariableValueMathField(mathField.latex(), $(mathField.el()).attr("type"));
            $(`.variable-value[rid='${$(mathField.el()).attr("rid")}']`).removeClass("error");
            try{//the input field may not have a tooltip connected to it so this line may not work
              $(`.variable-value[rid='${$(mathField.el()).attr("rid")}']`).tooltip("destroy");
            }catch(err){}
            if(valueFormattingError != undefined){
              //we found an error so we need to display it as a tooltip
              $(`.variable-value[rid='${$(mathField.el()).attr("rid")}']`).addClass("error");
              $(`.variable-value[rid='${$(mathField.el()).attr("rid")}']`).attr("data-tooltip",valueFormattingError);
              $(`.variable-value[rid='${$(mathField.el()).attr("rid")}']`).tooltip();
              $(`.variable-value[rid='${$(mathField.el()).attr("rid")}']`).tooltip("open");
            }else{
              //if there are no formatting errors in the text then we can show the default tooltip
              /*
              $(`.variable-value[rid='${$(mathField.el()).attr("rid")}']`).attr("data-tooltip","Edit value and press enter to update editor");
              $(`.variable-value[rid='${$(mathField.el()).attr("rid")}']`).tooltip();
              $(`.variable-value[rid='${$(mathField.el()).attr("rid")}']`).tooltip("open");
              */
            }
            FindAndUpdateVariableByRID({rid: $(mathField.el()).attr("rid"), value: mathField.latex(), valueFormattingError: valueFormattingError, type: $(mathField.el()).attr("type") });
          },
          enter: function(){
            DisplayLoadingBar(true);
            ExecutionID = RID();
            (debounce(function(executionID){
              if(executionID == ExecutionID){
                //console.log("currently parsing", EL.currentlyParsing);
                EL.GenerateEditorErrorMessages();
                DisplayLoadingBar(false);
              }
              
            }, 100))(ExecutionID);
          },
        }
      };
      
      if($(this).hasClass("static-mathfield")){
        //this means we are displaying a variable value for a known variable meaning the value shouldn't be able to be edited because the value was generated by the program
        MQ.StaticMath($(this).get(0)).latex($(this).attr("latex"));
      }
      else{
        let mf;
        if($(this).attr("latex") == ""){// if the latex equals nothing then all we have to do is initialize the mathField  
          // for some reason this element has html inside of it eventhough we haven't created the mathfield so we are removing any html before we initialize the math field
          $(this).html("");
          mf = MQ.MathField($(this).get(0), opts);
          //console.log("mf.latex()",mf.latex())
        }else{// if the latex attribute actually equals something then we need to initialize the mathfield with its correct latex information
          mf = MQ.MathField($(this).get(0), opts).latex($(this).attr("latex"));
        }
   
      }
    }
    
  });

  // one last thing we need to do is update the variable row of the variable the user is currently updating. This only involves any static mathfield that may be from a second variable on the same row or changing the units of the variable
  // first we are going to update any static variable-value mathfields
  let variableRowBeingUpdated = $(`#my_variables-collection-container .variable-row[${variableRIDAttribute}='${updatedVariableInfo.rid}']`);
  if(variableRowBeingUpdated.find('.variable-value.static-mathfield').length > 0){
    variableRowBeingUpdated.find('.variable-value.static-mathfield').attr('latex',collectionHTML.currentVariableBeingUpdated.find('.variable-value.static-mathfield').attr('latex'))
    // now that we have updated the latex of the static mathfield that may exist in the variable row we need to initialized the static mathfield again
    MQ.StaticMath(variableRowBeingUpdated.find('.variable-value.static-mathfield').get(0)).latex(variableRowBeingUpdated.find('.variable-value.static-mathfield').attr("latex"));
  }
  
  //tooltipping everything that was just created and needs a tooltip
  $("#my_variables .tooltipped").tooltip();

  //updating hover event
  $("#my_variables .variable-row").unbind("mouseout mouseover");
  $("#my_variables .variable-row").hover(function(){
    $("#my_variables .variable-row").removeClass('active');
    $(this).addClass('active');
  },function(){
    $(this).removeClass('active');
  });
  //checking how many variables are defined and if there are none adding the no-variables-defined class to the collection
  //this helps with ui look and feel
  if($("#my_variables .variable-row").length == 0){
    $("#my_variables .my-collection").addClass("no-variables-defined");
  }
  else{
    $("#my_variables .my-collection").removeClass("no-variables-defined");
  }

}

function FindFormattingErrorInVariableValueMathField(ls, type){

  // before we do anything we need to check that the ls is actually something and not just empty space
  if(ls.replace(/\\\s/g,"").replace(/\s*/g,"").length == 0){return;}

  //this function needs to check that there are no variables in the string and or vectors and that the string is formatted properly
  if(type == "scalar"){
    if(GetVariablesFromLatexString(ls).filter((variable) => {return !(["\\pi","e","i"].includes(variable))}).length > 0){
      //this if statement gets all the variables in the latex string and removes constants that nederamer can understand
      //and if there are any variables left over than the user is using variables and that is not allowed becauase the variable
      //value mathfield should only be taking in numbers and simple operations like multiplication, division, substraction and addition
      return "No variables allowed in input box! Only numbers";
    }
  }else if(type == "vector"){
    if(GetVariablesFromLatexString(ls).filter((variable) => {return !(["\\pi","e","i","\\hat{x}","\\hat{y}","\\hat{z}","\\hat{i}","\\hat{j}","\\hat{k}","\\hat{r}","\\hat{\\theta}","\\hat{\\phi}"].includes(variable))}).length > 0){
      //this if statement gets all the variables in the latex string and removes constants that nederamer can understand along with any unit vectors apart of a coordinate system
      //and if there are any variables left over than the user is using variables and that is not allowed becauase the variable
      //value mathfield should only be taking in numbers and simple operations like multiplication, division, substraction and addition
      return "No variables allowed in input box! Only numbers and unit vectors";
    }
  }
  
  
  //the next check is checking if there are any unallowed operations in the box like integral or summation or nabla stuff like that
  let notAllowedOperators = ["\\int", "\\oint", "\\sum", "\\prod", "\\triangledown","\\bigcup","\\coprod","\\circ","<", ">", "=", "\\doteq", "\\geq", "\\leq", "\\leqslant", "\\geqslant", "\\equiv", "\\neq", "\\ngtr", "\\nless", "\\nleqslant", "\\ngeqslant", "\\approx", "\\simeq", "\\cong", "\\propto", "\\left\\langle", "\\right\\rangle", "\\left \\{", "\\right \\}", "\\exp"];
  for(let i = 0; i < notAllowedOperators.length; i++){
    if(ls.indexOf(notAllowedOperators[i]) != -1){
      return "Found disallowed operator in input box"
    }
  }

  let expressionObj = ExactConversionFromLatexStringToNerdamerReadableString({
    ls: ls,
    uniqueRIDStringArray: UpdateUniqueRIDStringObjUsingLs(ls),
    lineNumber: 0,
    mfID: "0",
    throwError: false,
    convertVectorsToNerdamerMatrices: true,
    returnFinalObject: true,//return an array of the expressions we have to iterate through and the evaluated expression in latex
  });

  if(expressionObj == null){
    return "couldn't parse input";
  }else{
    // if we were able to parse the string then if the variable is a vector we need to make sure that the output of parsing is a vector as well
    if(type == "vector"){
      if(expressionObj.array.length == 1){// if the length is one we need to check if the 0 index has a unit vector ridString in it if it doesn't then we know that the resulting string is not a vector
        // because we are checking the first index there are only 4 possible unit vectors that can be at the zero index: "\\hat{x]","\\hat{i}","\\hat{r}","\\dim{1}"
        let zeroIndexUnitVectors = ["\\hat{x}","\\hat{i}","\\hat{r}","\\dim{1}"];
        if(zeroIndexUnitVectors.every((str) => {return expressionObj.array[0].indexOf(UniqueRIDStringObj[str].ridString) == -1})){
          // this means that none of the zero index unit vectors rid strings appeared in the string so the string doesn't represent a vector
          return "Input must be a vector"
        }
      }
    }
  }

  /*
  //last check is to run it through nerdamer and see if it throws up errors meaning the string is not formatted properly
  ls = CleanLatexString(ls, ["fractions","addition","parentheses","brackets", "white-space"]);
  ls = CleanLatexString(ls,["multiplication"]);
  ls = CleanLatexString(ls,["latexFunctions"]);
  try{
    let str = nerdamer.convertFromLaTeX(ls).toString();
    return undefined;//no error was found
  }
  catch(err){
    return "Formatting error detected";
  }
  */
  
}

function GetComponentsForVectorFromVariableValue(ls, variableLs){

  // before we do anything we need to check that the ls is actually something and not just empty space
  if(ls.replace(/\\\s/g,"").replace(/\s*/g,"").length == 0){return;}

  // this object will hold the data about the different components that make up the vector
  let components = {};
  let expressionObj = ExactConversionFromLatexStringToNerdamerReadableString({
    ls: ls,
    uniqueRIDStringArray: UpdateUniqueRIDStringObjUsingLs(ls),
    lineNumber: 0,
    mfID: "0",
    throwError: false,
    convertVectorsToNerdamerMatrices: true,
    returnFinalObject: true,//return an array of the expressions we have to iterate through and the evaluated expression in latex
  });

  // we know by this point that the latex string we are parsing is a vector so we don't have to check if it has a unit vector in the string
  let componentData;
  for(let i = 0; i < expressionObj.array.length; i++){
    componentData = RemoveUnitVectorRIDStringFromString(expressionObj.array[i]);
    components[`\\comp${i+1}{${variableLs}}`] = {
      value: componentData.str,
      unitVectorLs: (componentData.unitVectorLs != null) ? componentData.unitVectorLs : `\\dim{${i+1}}`,
    }
  }

  // so now that we have an object of components before we send it off we want to see if we can figure out the coordinate system the user is
  // trying to use for this vector. If we can, we will change generic demensions ("\\dim{n}") into their correct unit vector
  // for example: "\\dim{1}" -> "\\hat{i}". Additionally we will add another key value pair to define overall which coordinate system
  // the coordinates are using. Thats what this line below does
  components = FigureOutCoordinateSystemEachComponent(components);

  return components;
}

function FindAndUpdateVariableByRID(opts = {}){
  let foundVariable = false;
  let updatedVariable = false;
  let updatedVariableInfo = {
    rid: opts.rid,
    ls: undefined,
  };
  
  for(const [key, value] of Object.entries(DefinedVariables)){
    if(value.rid == opts.rid){
      foundVariable = true;
      updatedVariableInfo.ls = key;
      // we should only updated the variable if the value or valueFormattingError has actually changed
      if(DefinedVariables[key].value != opts.value || DefinedVariables[key].valueFormattingError != opts.valueFormattingError){
        updatedVariable = true;
        DefinedVariables[key].value = opts.value;
        DefinedVariables[key].valueFormattingError = opts.valueFormattingError;
        DefinedVariables[key].components = (opts.valueFormattingError == undefined && opts.type == "vector") ? GetComponentsForVectorFromVariableValue(opts.value, key) : undefined;
        CheckThatVectorMagnitudeVariableEqualsVectorMagnitude({
          variables: DefinedVariables,
          vectorLs: opts.type == "vector" ? key : `\\vec{${key}}`,
          vectorMagnitudeLs: opts.type == "vector" ? RemoveVectorLatexString(key) : key,
        });
      }
      break;
    }
  }

  if(!foundVariable){
    for(const [key, value] of Object.entries(EL.undefinedVars.undefined)){
      if(value.rid == opts.rid){
        foundVariable = true;
        updatedVariableInfo.ls = key;
        // we should only updated the variable if the value or valueFormattingError has actually changed
        if(EL.undefinedVars.undefined[key].value != opts.value || EL.undefinedVars.undefined[key].valueFormattingError != opts.valueFormattingError){
          updatedVariable = true;
          EL.undefinedVars.undefined[key].value = opts.value;
          EL.undefinedVars.undefined[key].valueFormattingError = opts.valueFormattingError;
          EL.undefinedVars.undefined[key].components = (opts.valueFormattingError == undefined && opts.type == "vector") ? GetComponentsForVectorFromVariableValue(opts.value, key) : undefined;
          CheckThatVectorMagnitudeVariableEqualsVectorMagnitude({
            variables: EL.undefinedVars.undefined,
            vectorLs: opts.type == "vector" ? key : `\\vec{${key}}`,
            vectorMagnitudeLs: opts.type == "vector" ? RemoveVectorLatexString(key) : key,
          });
        }
        break;  
      }
    }
  }

  if(!foundVariable){
    for(const [key, value] of Object.entries(EL.undefinedVars.defined)){
      if(value.rid == opts.rid){
        foundVariable = true;
        updatedVariableInfo.ls = key;
        // we should only updated the variable if the value or valueFormattingError has actually changed
        if(EL.undefinedVars.defined[key].value != opts.value || EL.undefinedVars.defined[key].valueFormattingError != opts.valueFormattingError){
          updatedVariable = true;
          EL.undefinedVars.defined[key].value = opts.value;
          EL.undefinedVars.defined[key].valueFormattingError = opts.valueFormattingError;
          EL.undefinedVars.defined[key].components = (opts.valueFormattingError == undefined && opts.type == "vector") ? GetComponentsForVectorFromVariableValue(opts.value, key) : undefined;
          CheckThatVectorMagnitudeVariableEqualsVectorMagnitude({
            variables: EL.undefinedVars.defined,
            vectorLs: opts.type == "vector" ? key : `\\vec{${key}}`,
            vectorMagnitudeLs: opts.type == "vector" ? RemoveVectorLatexString(key) : key,
          });
        }
        break;
      }
    }
  }

  if(updatedVariable){
    DisplayLoadingBar(true);
    ExecutionID = RID();
    (debounce(function(executionID, updatedVariableInfo){
      if(executionID == ExecutionID){
        EL.GenerateEditorErrorMessages({dontRenderMyVariablesCollection: true, updatedVariableInfo: updatedVariableInfo,});
        DisplayLoadingBar(false);
      }
      
    }, 1000))(ExecutionID, updatedVariableInfo);
  }

}

function UpdateMyVariablesCollection(opts = {ls: "", rid: "", update: true, add: false, pc: {}, remove: false, editable: true}){

  if(opts.add){
    //adding variable to defined variables
    UpdateDefinedVariables({
      type: "add",
      ls: opts.pc.symbol,
      rid: opts.rid,
      editable: opts.editable,
      props: {
        state: "given",
        type: 'physics constant',
        unitString: opts.pc.unitString,
        unit: opts.pc.unit,
        value: opts.pc.value,
        unitsMathjs: opts.pc.unitsMathjs,
        unitsLatex: opts.pc.unitsLatex,
        quantity: opts.pc.quantity,
        quantityDescription: opts.pc.quantityDescription
      },
    });
  }
  else if(opts.remove){
    if(!opts.cantRemove){
      //before we remove this variable we need to check if it is being used in the editor
      
      if(!isVariableBeingUsedInEditor({rid: opts.rid, editable: opts.editable})){
        //if it is a physics constant unchecking the box
        if($(`.physics-constant-checkbox-span[rid='${opts.rid}']`).length > 0 && opts.uncheckbox){
          $(`.physics-constant-checkbox-span[rid='${opts.rid}']`).prev().prop("checked",false);
        }

        if(opts.rid2 != undefined && !isVariableBeingUsedInEditor({rid: opts.rid2, editable: opts.editable})){
          // the user may want to remove two things at the same time. The use case is if the user clicks the "x" on a variable that holds both a vector and its vector magnitude
          //removing the second variable first from defined variables object and making sure we dont update the error messages quite yet beacuase we still got one more variable to remove which is the first 
          UpdateDefinedVariables({
            type: "remove",
            rid: opts.rid2,
            editable: opts.editable,
            updateErrorMessages: false, // we don't want to update the errro messages because we still got one more variable to remove  after what happens in this if statement
          });
        }
        //removing variable from defined variables object
        UpdateDefinedVariables({
          type: "remove",
          rid: opts.rid,
          editable: opts.editable,
        });
      }
      else{
        //if it is being used then we just show a notitication that the variable can't be deleted
        M.toast({html: "This variable can't be removed because it is being used", displayLength: 3000});
      }
    }
    else{
      //if it is being used then we just show a notitication that the variable can't be deleted
      M.toast({html: "This variable can't be removed because it is being used", displayLength: 3000});
    }

  }

  //after the variables have been edited we need to rerender the my variables collection
  OrderCompileAndRenderMyVariablesCollection();
  //after compiling a new variable collection we need to render any errors that may exist with the variable collection variables
  RenderVariableCollectionErrors();

}

function isVariableBeingUsedInEditor(opts){
  if(opts.rid == undefined){return false;}
  let vars = (opts.editable) ? (Object.assign({}, DefinedVariables)) : (Object.assign({}, PreDefinedVariables));
  let latexString = undefined;
  for (const [key, value] of Object.entries(vars)) {
    if(value.rid == opts.rid){
      latexString = key;
    }
  }
  //if we couldn't find the variable in the DefinedVariables then it has to be in the EL.undefinedVars.defined object
  if(latexString == undefined){
    vars = Object.assign({}, EL.undefinedVars.defined);
    for (const [key, value] of Object.entries(vars)) {
      if(value.rid == opts.rid){
        latexString = key;
      }
    }
  }

  if(latexString != undefined){
    for (const [key, value] of Object.entries(MathFields)) {
      //getting all the variables in a specific mathfield and checking if any of them match the latexString we are looking for
      if(GetVariablesFromLatexString(value.mf.latex()).indexOf(latexString) != -1){
        return true;
      }
    }
  }

  return false;

}

function CopyPhysicsEquationToClipboard(el){
  CopyToClipboard(el.attr("latex"));
  M.toast({html: "Equation copied to clipboard", displayLength: 3000});
}

function CopyPhysicsConstantToClipboard(el){
  CopyToClipboard(el.attr("latex"));
  M.toast({html: "physics constant copied to clipboard", displayLength: 3000});
}

function CopyToClipboard(str) {
  const el = document.createElement('textarea');
  el.value = str;
  el.setAttribute('readonly', '');
  el.style.position = 'absolute';
  el.style.left = '-9999px';
  document.body.appendChild(el);
  el.select();
  document.execCommand('copy');
  document.body.removeChild(el);
};

function CloseEditorLog(){
  $("#editor-log-container").animate({
    right: -0.416 * window.innerWidth,
  },250);
}

function OpenEditorLog(type){
  /*
  $('#editor-log-container .collapsible.log-container').collapsible('close', 0);
  $('#editor-log-container .collapsible.log-container').collapsible('close', 1);
  $('#editor-log-container .collapsible.log-container').collapsible('close', 2);
  $('#editor-log-container .collapsible.log-container').collapsible('close', 3);
  $(".success-log, .info-log, .warning-log, .error-log").removeClass('active');
  switch(type) {
    case 'success':
      $('#editor-log-container .collapsible.log-container').collapsible('open', 0);
      break;
    case 'info':
      $('#editor-log-container .collapsible.log-container').collapsible('open', 1);
      break;
    case 'warning':
      $('#editor-log-container .collapsible.log-container').collapsible('open', 2);
      break;
    case 'error':
      $('#editor-log-container .collapsible.log-container').collapsible('open', 3);
      break;
    default:
      // code block
  }
  $("#editor-log-container").animate({
    right: 0,
  },250);
  */
}

function GetLineNumberFromMathFieldId(mfId){
  return parseInt($(`#${mfId}`).parents(".editor_line").find(".line-number").html());
}

function CheckForAndDisplayRelevantEquations(){
  let usedQuantities = GetAllUsedQuantities();//an object that has the quantity as the key and true if it is known or and false if it is unknown
  //this function goes through the dom of physics equations and checks the quanities they relate and sees if the equation is relevant for the defined quanities in the editor
  //an equation is relevant when there are no quanitites that the user is not using  and when it has one quantity that the user is using and has set as known.
  //additionally the user has to have the same number of each quantity or more for an equation to be relevant
  //console.log(usedQuantities);
  let sections = ["mechanics-equations","thermal-equations","waves-optics-equations","electricity-magnetism-equations","modern-physics-equations"];

  let totalNumberOfRelevantEquationsInSection = 0;

  sections.map(function(section,index){

    let numberOfRelevantEquationsInSection = 0;

    $(`#physics_equations .${section} .static-physics-equation.mq-math-mode`).each(function(){
      let quantities = JSON.parse($(this).attr("quantities"));
      let logIt = false;
      //console.log($(this).attr("latex"));
      let isRelevantEquation = true;
      let atLeastOneKnownValue = false;
      for (const [key, value] of Object.entries(quantities)) {
        if(AcceptablePhysicalQuantities.includes(key)){
          if(usedQuantities[key] != undefined){//checking if user has defined the quantity that this equation uses
            if(usedQuantities[key].number >= value){//the user has defined this variable at least the same number of times this equation needs or more
              if(usedQuantities[key].state == "given" || usedQuantities[key].state == "known"){
                atLeastOneKnownValue = true;
              }
            }
            else{
              isRelevantEquation = false;//the equation is not relevant because this equation needs a specific quantity a specific number of times and the user hasn't defined a quantity enough times
              if(logIt){
                //console.log(1);
              }
              break;
            }
          }
          else{
            //if we can't find this quantity directly we need to check if it is a physics constant quantity which in that case the information would be stored under a general physics quantity name with a specific list of physics quantity descriptions
            if(usedQuantities[PhysicsConstantToQuantity[key]] != undefined){
              if(!usedQuantities[PhysicsConstantToQuantity[key]].quantityDescriptions.includes(key)){//if this specified quantity is not even included in the quantityDescriptions array which keeps track of specifics about the physical quantity then the equation is not relevant
                isRelevantEquation = false;//the equation is not relevant because there is a quantity that this equation needs that the user hasn't defined
                if(logIt){
                  //console.log(2);
                  //console.log("key",key);
                  //console.log("array", usedQuantities[PhysicsConstantToQuantity[key]].quantityDescriptions);
                }
                break;
              }
              else{
                atLeastOneKnownValue = true;//all quantityDescriptions holds information from physics constants which are automatically known
              }
            }
            else{
              isRelevantEquation = false;//the equation is not relevant because there is a quantity that this equation needs that the user hasn't defined
              if(logIt){
                //console.log(3);
                //console.log("key", key);
                //console.log("PhysicsConstantToQuantity[key]", PhysicsConstantToQuantity[key]);
                //console.log('usedQuantities[PhysicsConstantToQuantity[key]]', usedQuantities[PhysicsConstantToQuantity[key]]);
              }
              break;
            } 
          }
        }
        else{
          //console.log($(this).attr("latex"));
          //console.log(`misspelled key: ${key}`);
          isRelevantEquation = false;//misspelled quantity
          break;
        }
      }

      if(isRelevantEquation && atLeastOneKnownValue){
        $(this).parent().addClass("relevant-equation");
        numberOfRelevantEquationsInSection += 1;
      }
      else{
        $(this).parent().removeClass("relevant-equation");
      }

    });

    totalNumberOfRelevantEquationsInSection += numberOfRelevantEquationsInSection;

    //updating the label that shows how many relevant equations are in a specific physics equation section
    $(`#physics_equations .${section} .relevant-equations-badge`).html(numberOfRelevantEquationsInSection);
    if(numberOfRelevantEquationsInSection > 0){//making the badge and count visibile if there are relevant equations in this section
      $(`#physics_equations .${section} .relevant-equations-badge`).addClass('active');
    }
    else{
      $(`#physics_equations .${section} .relevant-equations-badge`).removeClass('active');
    }

  });

  $("#relevant-physics-equations-total-count > span").html(totalNumberOfRelevantEquationsInSection);
  if(totalNumberOfRelevantEquationsInSection > 0){
    $("#relevant-physics-equations-total-count").addClass("active");
  }
  else{
    $("#relevant-physics-equations-total-count").removeClass("active");
  }

}

function GetAllUsedQuantities(){
  let usedQuantities = {
    unitless: {number: 1000, state: "given"},//this is for any equation that needs a unitless variable we can assume any number can fit the job and because it is a number it is known. 1000 is just a big number so it meets any requirement for a specific equation
  };

  for (const [key, value] of Object.entries(PreDefinedVariables)) {
    if(value.quantity != undefined){
      if(usedQuantities[value.quantity] == undefined){
        usedQuantities[value.quantity] = {number: 1, state: value.state, quantityDescriptions: [value.quantityDescription] };
      }
      else{
        usedQuantities[value.quantity].number += 1;
        //we need to add the quantityDescription to the list of quantityDescriptions if it doesn't already exist
        if(!usedQuantities[value.quantity].quantityDescriptions.includes(value.quantityDescription)){
          usedQuantities[value.quantity].quantityDescriptions.push(value.quantityDescription);
        }
      }
    }
  }

  for (const [key, value] of Object.entries(DefinedVariables)) {
    if(value.quantity != undefined){
      if(usedQuantities[value.quantity] == undefined){
        usedQuantities[value.quantity] = {number: 1, state: value.state, quantityDescriptions: []};
      }
      else{
        usedQuantities[value.quantity].number += 1;
      }
    }
  }

  for (const [key, value] of Object.entries(EL.undefinedVars.defined)) {
    if(value.quantity != undefined){
      if(usedQuantities[value.quantity] == undefined){
        usedQuantities[value.quantity] = {number: 1, state: value.state, quantityDescriptions: []};
      }
      else{
        usedQuantities[value.quantity].number += 1;
      }
    }
  }

  return usedQuantities;
}

function DisablePhysicsConstantCheckboxesThatAreBeingUsed(){
  //first we need to make sure that all check boxes are enabled
  $(".physics-constant-checkbox-input").removeAttr("disabled");
  let physicsConstants = {};
  for (const [key, value] of Object.entries(PreDefinedVariables)) {
    if(value.type == "physics constant"){
      //pushing the latex string because this variable is a physics constant
      let ridOfPhysicsConstantCheckBox = $(`.physics-constant-checkbox-span[symbol='${key}']`).attr("rid");
      physicsConstants[key] = ridOfPhysicsConstantCheckBox;
    }
  }

  //when some edits the editor we need to check if the auto generated variables are being used and if not we need to remove them
  for (const [key, obj] of Object.entries(MathFields)) {
    let physicsConstantsKeys = Object.keys(physicsConstants);
    if(physicsConstantsKeys.length > 0){//making sure there are physics constants to check
      let ls = obj.mf.latex();//getting the latex string from a specific mathfield
      let vars = GetVariablesFromLatexString(ls);

      for(let i = 0; i <  physicsConstantsKeys.length; i++){
        //loop through the physicsConstants check if the variable is included in the vars list.
        //if it is then we know this physicsConstant variable is being used so we remove it from the list of physicsConstants.
        if(vars.includes(physicsConstantsKeys[i])){
          $(`.physics-constant-checkbox-input[rid='${physicsConstants[physicsConstantsKeys[i]]}']`).attr("disabled","disabled");
          delete physicsConstants[physicsConstantsKeys[i]];//then we remove this physics constant because we have already disabled it
        }
      }
    }
  }

}


function CheckIfAutoGeneratedVariablesAreBeingUsed(){

  let autoGeneratedVars = [];
  for (const [key, value] of Object.entries(DefinedVariables)) {
    if(value.autoGenerated){
      //pushing the latex string because this variable is auto Generated
      autoGeneratedVars.push(key);
    }
  }

  //when some edits the editor we need to check if the auto generated variables are being used and if not we need to remove them
  for (const [key, obj] of Object.entries(MathFields)) {
    if(autoGeneratedVars.length > 0){
      let ls = obj.mf.latex();//getting the latex string from a specific mathfield
      let vars = GetVariablesFromLatexString(ls);

      for(let i = 0; i < autoGeneratedVars.length; i++){
        //loop through the autoGeneratedVars array and check if the variable is included in the vars list.
        //if it is then we know this autoGenerated variable is being used so we remove it from the list of autoGeneratedVars.
        if(vars.includes(autoGeneratedVars[i])){
          autoGeneratedVars.splice(i,1);
          i--;//to adjust for the shift in indexes after the splice
        }
      }
    }
  }

  //after we have looped through all of the mathfields and checked all the auotGenerated variables the autoGeneratedVars array will only have the unused auto Generated variables in it
  //so we take this list of keys that are latex string and will remove these variables
  for(let i = 0; i < autoGeneratedVars.length; i++){
    UpdateMyVariablesCollection({rid: DefinedVariables[autoGeneratedVars[i]].rid, remove: true, editable: true});
  }
}

function RemoveDifferentialOperatorDFromLatexString(ls){
  let acceptableStrings = ["\\vec","\\dot"].concat("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split("")).concat(LatexGreekLetters);
  let newLs = "";
  let i = 0;
  let str = "";
  let delta = 1;
  let skipCharacter = false;
  while(i < ls.length){
    delta = 1;
    skipCharacter = false;
    str = ls.substring(i);
    if(str.indexOf("\\frac{d}{d") == 0 && str.length > "\\frac{d}{d".length){//checking that the "d" we are looking at is not the last character in the string if it is we must assume that it is not a differntial operator
      for(let c = 0; c < acceptableStrings.length; c++){
        if(str.substring("\\frac{d}{d".length).indexOf(acceptableStrings[c]) == 0){//this means that the acceptable character comes right after "d" and uses "d" as a differntial operator for example the equation: dxdydz=dv, where x,y,z,v all use "d" as an operator
          skipCharacter = true;//we want to skip this character
          delta = "\\frac{d}{d".length;
          newLs+= "\\frac{1}{";//adjusting the string so that "\\frac{d}{dt}" -> "\\frac{1}{t}"
          break;//once we find a character that works we don't have to continue to parse through the rest of the array
        }
      }
    }
    else if(str.indexOf("\\frac{d^{2}}{d") == 0 && str.length > "\\frac{d^{2}}{d".length){//checking that the "d" we are looking at is not the last character in the string if it is we must assume that it is not a differntial operator
      for(let c = 0; c < acceptableStrings.length; c++){
        if(str.substring("\\frac{d^{2}}{d".length).indexOf(`${acceptableStrings[c]}^{2}`) == 0){//this means that the acceptable character comes right after "d" and uses "d" as a differntial operator for example the equation: dxdydz=dv, where x,y,z,v all use "d" as an operator
          skipCharacter = true;//we want to skip this character
          delta = "\\frac{d^{2}}{d".length;
          newLs+= "\\frac{1}{";//adjusting the string so that "\\frac{d}{dt}" -> "\\frac{1}{t}"
          break;//once we find a character that works we don't have to continue to parse through the rest of the array
        }
      }
    }
    else if(str.indexOf("\\frac{\\partial}{\\partial ") == 0 && str.length > "\\frac{\\partial}{\\partial ".length){//checking that the "d" we are looking at is not the last character in the string if it is we must assume that it is not a differntial operator
      for(let c = 0; c < acceptableStrings.length; c++){
        if(str.substring("\\frac{\\partial}{\\partial ".length).indexOf(acceptableStrings[c]) == 0){//this means that the acceptable character comes right after "d" and uses "d" as a differntial operator for example the equation: dxdydz=dv, where x,y,z,v all use "d" as an operator
          skipCharacter = true;//we want to skip this character
          delta = "\\frac{\\partial}{\\partial ".length;
          newLs+= "\\frac{1}{";//adjusting the string so that "\\frac{d}{dt}" -> "\\frac{1}{t}"
          break;//once we find a character that works we don't have to continue to parse through the rest of the array
        }
      }
    }
    else if(str.indexOf("\\frac{\\partial^{2}}{\\partial ") == 0 && str.length > "\\frac{\\partial^{2}}{\\partial ".length){//checking that the "d" we are looking at is not the last character in the string if it is we must assume that it is not a differntial operator
      for(let c = 0; c < acceptableStrings.length; c++){
        if(str.substring("\\frac{\\partial^{2}}{\\partial ".length).indexOf(`${acceptableStrings[c]}^{2}`) == 0){//this means that the acceptable character comes right after "d" and uses "d" as a differntial operator for example the equation: dxdydz=dv, where x,y,z,v all use "d" as an operator
          skipCharacter = true;//we want to skip this character
          delta = "\\frac{\\partial^{2}}{\\partial ".length;
          newLs+= "\\frac{1}{";//adjusting the string so that "\\frac{d}{dt}" -> "\\frac{1}{t}"
          break;//once we find a character that works we don't have to continue to parse through the rest of the array
        }
      }
    }
    else if(str[0] == "d" && str.length > 1){//checking that the "d" we are looking at is not the last character in the string if it is we must assume that it is not a differntial operator
      for(let c = 0; c < acceptableStrings.length; c++){
        if(str.indexOf(acceptableStrings[c]) == 1){//this means that the acceptable character comes right after "d" and uses "d" as a differntial operator for example the equation: dxdydz=dv, where x,y,z,v all use "d" as an operator
          skipCharacter = true;//we want to skip this character
          delta = 1;
          break;//once we find a character that works we don't have to continue to parse through the rest of the array
        }
      }

    }
    else if(str.indexOf("\\Delta ") == 0 && str.length > "\\Delta ".length){//checking that the "d" we are looking at is not the last character in the string if it is we must assume that it is not a differntial operator
      for(let c = 0; c < acceptableStrings.length; c++){
        if(str.substring("\\Delta ".length).indexOf(acceptableStrings[c]) == 0){//this means that the acceptable character comes right after "d" and uses "d" as a differntial operator for example the equation: dxdydz=dv, where x,y,z,v all use "d" as an operator
          skipCharacter = true;//we want to skip this character
          delta = "\\Delta ".length;
          break;//once we find a character that works we don't have to continue to parse through the rest of the array
        }
      }
    }
    else if(str.indexOf("\\Delta") == 0 && str.length > "\\Delta".length){//we check for \Delta again without a space because in latex when a latex string comes after another one there is no need for a space. the space is only for no latex strings
      for(let c = 0; c < acceptableStrings.length; c++){
        if(str.substring("\\Delta".length).indexOf(acceptableStrings[c]) == 0){//this means that the acceptable character comes right after "d" and uses "d" as a differntial operator for example the equation: dxdydz=dv, where x,y,z,v all use "d" as an operator
          skipCharacter = true;//we want to skip this character
          delta = "\\Delta".length;
          break;//once we find a character that works we don't have to continue to parse through the rest of the array
        }
      }
    }
    else if(str.indexOf("\\partial ") == 0 && str.length > "\\partial ".length){//checking that the "\\partial" we are looking at is not the last character in the string if it is we must assume that it is not a differntial operator
      for(let c = 0; c < acceptableStrings.length; c++){
        if(str.substring("\\partial ".length).indexOf(acceptableStrings[c]) == 0){//this means that the acceptable character comes right after "d" and uses "d" as a differntial operator for example the equation: dxdydz=dv, where x,y,z,v all use "d" as an operator
          skipCharacter = true;//we want to skip this character
          delta = "\\partial ".length;
          break;//once we find a character that works we don't have to continue to parse through the rest of the array
        }
      }

    }
    else if(str.indexOf("\\partial") == 0 && str.length > "\\partial".length){//we check for \Delta again without a space because in latex when a latex string comes after another one there is no need for a space. the space is only for no latex strings
      for(let c = 0; c < acceptableStrings.length; c++){
        if(str.substring("\\partial".length).indexOf(acceptableStrings[c]) == 0){//this means that the acceptable character comes right after "d" and uses "d" as a differntial operator for example the equation: dxdydz=dv, where x,y,z,v all use "d" as an operator
          skipCharacter = true;//we want to skip this character
          delta = "\\partial".length;
          break;//once we find a character that works we don't have to continue to parse through the rest of the array
        }
      }
    }
    else if(str.indexOf("_{") == 0 || str.indexOf("^{") == 0){
      //we don't parse any information in a sup or sub because those wouldnt have any actual operations happening inside them so we just record everything inside these ranges and move on
      delta = FindIndexOfClosingBracket(str.substring(2)) + 3;//adding 2 this value would get us to the index of the closing bracket and then adding one more would get us to the next character we want to parse
    }
    else if(str.indexOf("\\") == 0){
      let a = ListOfOperators.concat(LatexGreekLetters).concat(["\\dot{"]);//this is a list of special latex strings that we should not parse and just add to newLs
      for(let i = 0; i < a.length; i++){
        if(str.indexOf(a[i]) == 0){//if we find a match then change delta and stop parsing through the array
          delta = a[i].length;
          break;
        }
      }
    }

    if(!skipCharacter){
      newLs += ls.substring(i, i + delta);//recording information into newLs
    }

    i += delta;
  }
  return newLs;
}

function FormatNablaSquared(ls){
  //we need to replace all instances of \nabla^2 with \nabla \cdot \nabla for our editor to know what we mean
  return ls.replace(/nabla\^2/g,"\\nabla\\cdot\\nabla ");

}

function OrderMathFieldIdsByLineNumber(ids){
  let orderedIds = {};
  for(var i = 0; i < ids.length; i++){
    orderedIds[GetLineNumberFromMathFieldId(ids[i])] = ids[i];
  }

  return orderedIds;
}

function DefineVariableUnits(el, rid, rid2){
  if(!UnitsDropdownMenuOpen){//if the menu is not open then open it
    //expanding unit badge
    //ToggleVariableBadgeUnitsSize(el, rid, rid2, true);
    //displaying dropdown search menu
    DisplayUnitDropdownSearchMenu(el, rid, rid2);
  }
}

function ToggleVariableBadgeUnitsSize(el = null, rid = "", rid2 = null,  expand = false){
  if(expand){
    //we need to calculate how large to expand it
    let w = el.parent(".variable-row").width() - $(`.static-physics-equation[rid='${rid}']`).width() - 185;
    if(el.prev().hasClass("known")){
      w -= 50;//this is because this tag takes more space up so we need to make the expand not as big
    }
    el.css("width",`${w}px`);
  }
  else{
    $("#my_variables-collection-container .variable-row .units").css("width","auto");
  }
}

function DisplayUnitDropdownSearchMenu(el, rid = "", rid2 = null){
  let r = el[0].getBoundingClientRect();
  let left;
  let menuDropDownWidth = 300;//this is the min width of the dropdown box
  //making sure that hte display unit dropdown doesnt extend past the width of the page and if it does we will subtract a specific amount from the left so that the element moves more left and get on to the screen application
  if(r.left + menuDropDownWidth > window.innerWidth){
    left = r.left - (r.left + menuDropDownWidth - window.innerWidth) - 10;
  }else{
    left = r.left;
    menuDropDownWidth = window.innerWidth - r.left - 10;
  }
  
  if(r.top < window.innerHeight / 2){
    $("#units-dropdown-menu").css({top: r.top + r.height + 5, left: left, width: menuDropDownWidth, display: "block"});
  }
  else{
    $("#units-dropdown-menu").css({top: r.top - ($("#units-dropdown-menu").height() + 5), left: left, width: menuDropDownWidth, display: "block"});
  }

  //setting value so that the menu knowns what to update once the user has chosen the unit they want
  $("#units-search-results").attr("rid",rid);
  if(rid2 != null){
    $("#units-search-results").attr("rid2",rid2);
  }else{
    $("#units-search-results").removeAttr("rid2");
  }

  //the element could have a search attribute which tells the dropdown what should by default already be searched in the dropdown
  $("#input-user-units-search").val(el.attr("search") != null ? el.attr("search") : "");
  //focusing the input field so the user doesn't have to click they can just start typing
  $("#input-user-units-search").focus();

  RenderSIUnitsSearch();//start a search to bring up all the variables

  //this line of code is needed because we need a slight delay so that the dropdown is not immediately closed by MainScreenClicked() function
  setTimeout(function(){UnitsDropdownMenuOpen = true;}, 500);

}

function RenderSIUnitsSearch(){
  //everytime you search you should disable the updated button because no si unit is selected
  $("#btn-update-variable-units").addClass("disabled");
  let search = $("#input-user-units-search").val();
  let searchMathJsUnits = ParseStringIntoMathJsString(search);
  search = search.toLowerCase();// we apply make everything lower case after we have attempted to get the searches units because some SI Units for example Hertz (Hz) are case sensitive
  let results = [];
  for(const [key, value] of Object.entries(UnitReference)){
    if(key.toLowerCase().indexOf(search) != -1){
      results.push(key);
    }else if(searchMathJsUnits != null){
      // we are seeing if we can figure out the units of this search and see if the units of the search match the units of this specific variable
      try{
        math.evaluate(`${searchMathJsUnits} + ${value.unitsMathjs}`);
        results.push(key);
      }catch(err){}//don't do anything if there is an error
    }
  }
  let html = ejs.render(Templates["units-search-results"], {results: results});
  $("#units-search-results").html(html);
}

function CloseUnitDropdownSearchMenu(){
  UnitsDropdownMenuOpen = false;
  $("#units-dropdown-menu").css({display: "none", top: -1000});
  $("#input-user-units-search").val("");
  $("#units-search-results").html("");
  $("#btn-update-variable-units").removeAttr("rid");
  $("#btn-update-variable-units").addClass("disabled");
  ToggleVariableBadgeUnitsSize();
}

function UpdateVariableUnitsWithCustomVariable(){

  if($("#btn-create-custom-unit").hasClass("disabled") || NewCustomUnit.mathjs == null || NewCustomUnit.latex == null){
    return;
  }

  // if the custom unit modal is open we need to close it. This function could have been called from dom elements that reside in it
  $("#modal-create-custom-unit").modal("close");

  let rid = $("#units-search-results").attr("rid");
  let rid2 = $("#units-search-results").attr("rid2");

  let foundVariable = false;
  let foundVariable2 = false;
  let ls = "";
  let ls2 = "";
  let props = {};
  let props2 = {}; // this holds the data of the second variable is there is an second rid we have to use to find the second variable

  for(const [key, value] of Object.entries(DefinedVariables)){
    if(value.rid == rid){
      foundVariable = true;
      ls = key;
      //copying over data
      props.type = value.type;
      props.state = value.state;
      props.value = value.value;
      props.valueFormattingError = value.valueFormattingError;
      
      break;
    }
  }

  if(!foundVariable){
    for(const [key, value] of Object.entries(EL.undefinedVars.undefined)){
      if(value.rid == rid){
        foundVariable = true;
        ls = key;
        //copying over data
        props.type = value.type;
        props.state = value.state;
        props.value = value.value;
        props.valueFormattingError = value.valueFormattingError;
        break;
      }
    }
  }

  if(!foundVariable){
    for(const [key, value] of Object.entries(EL.undefinedVars.defined)){
      if(value.rid == rid){
        foundVariable = true;
        ls = key;
        //copying over data
        props.type = value.type;
        props.state = value.state;
        props.value = value.value;
        props.valueFormattingError = value.valueFormattingError;
        break;
      }
    }
  }

  props.fullUnitsString = (NewCustomUnit.mathjs == "1") ? "unitless" : NewCustomUnit.mathjs.substring(1);//remove the coefficient 1 in front of the units
  props.units = (NewCustomUnit.mathjs == "1") ? "unitless" : NewCustomUnit.mathjs.substring(1);//remove the coefficient 1 in front of the units
  props.unitsMathjs = NewCustomUnit.mathjs;
  props.unitsLatex = NewCustomUnit.latex;
  props.quantity = "custom";
  props.canBeVector = true;

  //before we update defined variables with the first variable we need to check if the user has two variables they want to be updated
  if(rid2 != undefined){
    // we are going to do exactly what we did for the first variable with the second one. This is literally an exact copy just using "props2" and "foundVariable2"
    for(const [key, value] of Object.entries(DefinedVariables)){
      if(value.rid == rid2){
        foundVariable2 = true;
        ls2 = key;
        //copying over data
        props2.type = value.type;
        props2.state = value.state;
        props2.value = value.value;
        props2.valueFormattingError = value.valueFormattingError;
        
        break;
      }
    }
  
    if(!foundVariable2){
      for(const [key, value] of Object.entries(EL.undefinedVars.undefined)){
        if(value.rid == rid2){
          foundVariable2 = true;
          ls2 = key;
          //copying over data
          props2.type = value.type;
          props2.state = value.state;
          props2.value = value.value;
          props2.valueFormattingError = value.valueFormattingError;
          break;
        }
      }
    }
  
    if(!foundVariable2){
      for(const [key, value] of Object.entries(EL.undefinedVars.defined)){
        if(value.rid == rid2){
          foundVariable2 = true;
          ls2 = key;
          //copying over data
          props2.type = value.type;
          props2.state = value.state;
          props2.value = value.value;
          props2.valueFormattingError = value.valueFormattingError;
          break;
        }
      }
    }
  
    props2.fullUnitsString = (NewCustomUnit.mathjs == "1") ? "unitless" : NewCustomUnit.mathjs.substring(1);//remove the coefficient 1 in front of the units
    props2.units = (NewCustomUnit.mathjs == "1") ? "unitless" : NewCustomUnit.mathjs.substring(1);//remove the coefficient 1 in front of the units
    props2.unitsMathjs = NewCustomUnit.mathjs;
    props2.unitsLatex = NewCustomUnit.latex;
    props2.quantity = "custom";
    props2.canBeVector = true;

    //now that we have all the data for the second variable we will update the defined variables
    UpdateDefinedVariables({
      type: "update",
      ls: ls2,
      editable: true,
      props: props2,
      updateErrorMessages: false,// we are setting this to false because the first variable we found will do that for us because we still haven't run the UpdateDefinedVariable function for that variable but we will run it right after this if statement as you can see
    });
  }

  UpdateDefinedVariables({
    type: "update",
    ls: ls,
    editable: true,
    props: props,
  });

  CloseUnitDropdownSearchMenu();

  //then after we have edited either DefinedVariables or EL.undefinedVars.defined then we need to update the collection with the new information
  UpdateMyVariablesCollection({update: true});

}

function UpdateVariableUnits(el){

  // if the custom unit modal is open we need to close it. This function could have been called from dom elements that reside in it
  $("#modal-create-custom-unit").modal("close");

  let rid = $("#units-search-results").attr("rid");
  let rid2 = $("#units-search-results").attr("rid2");
  let fullUnitsString = el.attr("fullUnitssString");


  if(fullUnitsString.indexOf("undefined") != -1){//the user is setting the variable back to undefined
    if(rid2 != undefined){
      UpdateDefinedVariables({
        type: "remove",
        addToUndefinedVariables: true,// we don't just want to remove this variable from DefinedVariables we also want to add it to undefinedVars.undefined so its data like its state and value can be recorded and perserved
        rid: rid2,
        editable: true,
        updateErrorMessages: false,// we don't want to update error messages because the first variable with rid of "rid" will do that for us once we UpdateDefinedVariables in the lines below
      });
    }
    UpdateDefinedVariables({
      type: "remove",
      addToUndefinedVariables: true,// we don't just want to remove this variable from DefinedVariables we also want to add it to undefinedVars.undefined so its data like its state and value can be recorded and perserved
      rid: rid,
      editable: true,
    });
  }
  else{

    let foundVariable = false;
    let ls = "";
    let props = {};
    let foundVariable2 = false;
    let ls2 = "";
    let props2 = {};

    for(const [key, value] of Object.entries(DefinedVariables)){
      if(value.rid == rid){
        foundVariable = true;
        ls = key;
        //copying over data
        props.type = value.type;
        props.state = value.state;
        props.value = value.value;
        props.valueFormattingError = value.valueFormattingError;
        
        break;
      }
    }

    if(!foundVariable){
      for(const [key, value] of Object.entries(EL.undefinedVars.undefined)){
        if(value.rid == rid){
          foundVariable = true;
          ls = key;
          //copying over data
          props.type = value.type;
          props.state = value.state;
          props.value = value.value;
          props.valueFormattingError = value.valueFormattingError;
          break;
        }
      }
    }

    if(!foundVariable){
      for(const [key, value] of Object.entries(EL.undefinedVars.defined)){
        if(value.rid == rid){
          foundVariable = true;
          ls = key;
          //copying over data
          props.type = value.type;
          props.state = value.state;
          props.value = value.value;
          props.valueFormattingError = value.valueFormattingError;
          break;
        }
      }
    }

    props.fullUnitsString = fullUnitsString;
    props.units = TrimUnitInputValue(fullUnitsString);
    props.unitsMathjs = UnitReference[fullUnitsString].unitsMathjs;
    props.unitsLatex = UnitReference[fullUnitsString].unitsLatex;
    props.quantity = UnitReference[fullUnitsString].quantity;
    props.canBeVector = UnitReference[fullUnitsString].canBeVector;

    if(rid2 != undefined){// if the user has a second rid we need to account for then we will do everything we did with the first rid with the second
      for(const [key, value] of Object.entries(DefinedVariables)){
        if(value.rid == rid2){
          foundVariable2 = true;
          ls2 = key;
          //copying over data
          props2.type = value.type;
          props2.state = value.state;
          props2.value = value.value;
          props2.valueFormattingError = value.valueFormattingError;
          
          break;
        }
      }
  
      if(!foundVariable2){
        for(const [key, value] of Object.entries(EL.undefinedVars.undefined)){
          if(value.rid == rid2){
            foundVariable2 = true;
            ls2 = key;
            //copying over data
            props2.type = value.type;
            props2.state = value.state;
            props2.value = value.value;
            props2.valueFormattingError = value.valueFormattingError;
            break;
          }
        }
      }
  
      if(!foundVariable2){
        for(const [key, value] of Object.entries(EL.undefinedVars.defined)){
          if(value.rid == rid2){
            foundVariable2 = true;
            ls2 = key;
            //copying over data
            props2.type = value.type;
            props2.state = value.state;
            props2.value = value.value;
            props2.valueFormattingError = value.valueFormattingError;
            break;
          }
        }
      }
  
      props2.fullUnitsString = fullUnitsString;
      props2.units = TrimUnitInputValue(fullUnitsString);
      props2.unitsMathjs = UnitReference[fullUnitsString].unitsMathjs;
      props2.unitsLatex = UnitReference[fullUnitsString].unitsLatex;
      props2.quantity = UnitReference[fullUnitsString].quantity;
      props2.canBeVector = UnitReference[fullUnitsString].canBeVector;

      UpdateDefinedVariables({
        type: "update",
        ls: ls2,
        editable: true,
        props: props2,
        updateErrorMessages: true,// we don't want to update the error message because the first variable with rid of "rid" will do that for us in the lines below
      });

    }

    UpdateDefinedVariables({
      type: "update",
      ls: ls,
      editable: true,
      props: props,
    });

  }

  CloseUnitDropdownSearchMenu();

  //then after we have edited either DefinedVariables or EL.undefinedVars.defined then we need to update the collection with the new information
  UpdateMyVariablesCollection({update: true});

}

function ParseAndRenderCustomUnit(){
  let error = null;
  let customUnitString = $("#input-custom-unit").val();
  let latexCustomUnitString = null;
  let formattedLatexCustomUnitString = null;
  let mathJsCustomUnitString = null;
  //first we need to make sure that there are no + or - in the string
  if(customUnitString.indexOf("+") != -1){
    error = "Addition or subtraction is not allowed in string";
  }else if(customUnitString.replace(/\s*/g,"").length == 0){
    error = "empty string";
  }
  //next we need to make sure that all the characters in the string are either representing units or are some type of multiplication, division, or exponent
  if(error == null){
    // we will check that all the characters in the string are supported by removing all the supported characters and then seeing if there is anything left in the string
    let strReplaceEverything = customUnitString;
    let r;
    let thingsToReplace = SupportedSIUnits.concat([/\^\d\d*/,/\^-\d\d*/, /\^\(-\d\d*\)/, /\^\(\d\d*\)/, /\//,/\*/,/\s*/,/\(/,/\)/]);
    for(let i = 0; i < thingsToReplace.length; i++){
      r = new RegExp(thingsToReplace[i], 'g');
      strReplaceEverything = strReplaceEverything.replace(r,"")
    }

    if(strReplaceEverything.length > 0){
      error = "String is formatted incorrectly or has unsupported character";
    }
  }

  // if error still equals null then we need to see if nerdamer can parse the string and if it can then we will run the string in math js and then convert it to a latex to display
  if(error == null){
    try{
      mathJsCustomUnitString = nerdamer(customUnitString).toString();
    }catch(err){
      mathJsCustomUnitString = null;
      error = "String is formatted incorrectly";
    }

    //console.log("mathJsCustomUnitString",mathJsCustomUnitString);

    if(mathJsCustomUnitString != null){
      mathJsCustomUnitString = math.evaluate(isNaN(mathJsCustomUnitString) ? `1 ${mathJsCustomUnitString}` : mathJsCustomUnitString).toString();
      latexCustomUnitString = nerdamer.convertToLaTeX(isNaN(mathJsCustomUnitString) ? WrapAllNegativeExponentsWithParentheses(mathJsCustomUnitString.substring(1)) : mathJsCustomUnitString).toString();
      // we replace "\\cdot" with "\\y" because "\\cdot" because the "cd" part of "\\cdot" was getting parsed as the unit candela
      formattedLatexCustomUnitString = latexCustomUnitString.replace(/\\cdot/,"\\y");
      // after we need to rap each unit with \\mathrm{}
      let r;
      for(let i = 0; i < SupportedSIUnits.length; i++){
        r = new RegExp(SupportedSIUnits[i], 'g');
        //we replace it with \\x because if we replace it with \\mathrm the "m" could be caught up in the replace
        formattedLatexCustomUnitString = formattedLatexCustomUnitString.replace(r,`\\x{${SupportedSIUnits[i]}}`);
      }


      formattedLatexCustomUnitString = formattedLatexCustomUnitString.replace(/\\x\{/g,`\\mathrm{`).replace(/\\y/g,`\\cdot`);


      //console.log("mathJsCustomUnitString",mathJsCustomUnitString);
      //console.log("formattedLatexCustomUnitString",formattedLatexCustomUnitString);
    }
  }

  // now that we have all the data we need we need to display the data
  StaticMathFieldCustomUnit.latex(formattedLatexCustomUnitString != null ? formattedLatexCustomUnitString : "");
  $("#helper-text-input-custom-unit").html(error != null ? error : "");

  // saving the data if everything is formatted correctly
  if(mathJsCustomUnitString != null && latexCustomUnitString != null){
    NewCustomUnit = {
      mathjs: mathJsCustomUnitString,
      latex: latexCustomUnitString,
    }
    //enabling button if everything is formatted correctly
    $("#btn-create-custom-unit").removeClass("disabled");

    let results = [];
    for(const [key, value] of Object.entries(UnitReference)){
      try{
        math.evaluate(`${mathJsCustomUnitString} + ${value.unitsMathjs}`);
        results.push(key);
      }catch(err){
        
      }
    }

    let html = ejs.render(Templates["units-search-results"], {results: results});
    $("#quantities-match-custom-units").html(html);

  }else{
    NewCustomUnit = {
      mathjs: null,
      latex: null,
    };

    //disabling button if the string is not formatted correctly
    $("#btn-create-custom-unit").addClass("disabled");

    $("#quantities-match-custom-units").html("");
  }

}

function ParseStringIntoMathJsString(str){//this is a spin off of ParseAndRenderCustomUnit function. Except we are only interested in getting a mathjs unit string from the input string
  let error = null;
  let mathJsCustomUnitString = null;
  //first we need to make sure that there are no + or - in the string
  if(str.indexOf("+") != -1){
    error = "Addition or subtraction is not allowed in string";
  }else if(str.replace(/\s*/g,"").length == 0){
    error = "empty string";
  }
  //next we need to make sure that all the characters in the string are either representing units or are some type of multiplication, division, or exponent
  if(error == null){
    // we will check that all the characters in the string are supported by removing all the supported characters and then seeing if there is anything left in the string
    let strReplaceEverything = str;
    let r;
    let thingsToReplace = SupportedSIUnits.concat([/\^\d\d*/,/\^-\d\d*/, /\^\(-\d\d*\)/, /\^\(\d\d*\)/, /\//,/\*/,/\s*/,/\(/,/\)/]);
    for(let i = 0; i < thingsToReplace.length; i++){
      r = new RegExp(thingsToReplace[i], 'g');
      strReplaceEverything = strReplaceEverything.replace(r,"")
    }
    //console.log("strReplaceEverything",strReplaceEverything);

    if(strReplaceEverything.length > 0){
      error = "String is formatted incorrectly or has unsupported character";
    }
  }

  // if error still equals null then we need to see if nerdamer can parse the string and if it can then we will run the string in math js and then convert it to a latex to display
  if(error == null){
    try{
      mathJsCustomUnitString = nerdamer(str).toString();
    }catch(err){
      mathJsCustomUnitString = null;
      error = "String is formatted incorrectly";
    }

    //console.log("mathJsCustomUnitString",mathJsCustomUnitString);

    if(mathJsCustomUnitString != null){
      mathJsCustomUnitString = math.evaluate(isNaN(mathJsCustomUnitString) ? `1 ${mathJsCustomUnitString}` : mathJsCustomUnitString).toString();
    }
  }

  return mathJsCustomUnitString;

}

function WrapAllNegativeExponentsWithParentheses(str){
  //this function takes a math js string and wraps all of the negative exponents with parentheses
  let i1;
  let i2;
  let numString = "";
  while(str.indexOf("^-") != -1){
    i1 = str.indexOf("^-");
    i2 = str.substring(i1 + "^-".length).indexOf(" ");
    if(i2 == -1){
      // this means we have reached the end of the string so the number we are trying to grab resides after "^-" till the end of the string
      str = `${str.substring(0, i1 + 1)}(-${str.substring(i1 + "^-".length)})`;
    }else{
      i2 += i1 + "^-".length;//accounts for the shift because we used a substring of str
      str = `${str.substring(0, i1 + 1)}(-${str.substring(i1 + "^-".length, i2)}) ${str.substring(i2+1)}`;
    }
  }

  return str;
}


function MainScreenClicked(e){
  if(UnitsDropdownMenuOpen){
    if($("#units-dropdown-menu").find(e.target).length == 0){
      CloseUnitDropdownSearchMenu();
    };
  }
}

function KeyLogger(e){
  e = e || event; // to deal with IE
  EditorKeyPresses[e.keyCode] = (e.type == 'keydown');
  CheckHotKeys();
}

function CheckHotKeys(){
  if(HotKeySequenceReset){
    if(EditorKeyPresses[91] && EditorKeyPresses[66]){//ctrl+b
      //there are two scenerios why a user may be clicking control be. (1) they are trying to generate the vector sign
      EditingMathFields = true;//we need to edit the latex but we dont want these edits to be parsed because they are just intermeditate steps for us to get the information we want
      let currentLs = MathFields[FocusedMathFieldId].mf.latex();
      MathFields[FocusedMathFieldId].mf.write("$#!$");
      let changedLs = MathFields[FocusedMathFieldId].mf.latex().split("\\$#!\\$");//using this as the delimeter because latex puts backslashs infront of dollar signs
      let startIndex = currentLs.indexOf(changedLs[0]) + changedLs[0].length;
      let endIndex = currentLs.lastIndexOf(changedLs[1]);
      let selectedString = currentLs.substring(startIndex, endIndex);
      //selecting the delimiter that we injected into the string
      MathFields[FocusedMathFieldId].mf.keystroke("Shift-Left");//selects $
      MathFields[FocusedMathFieldId].mf.keystroke("Shift-Left");//selects !$
      MathFields[FocusedMathFieldId].mf.keystroke("Shift-Left");//selects #!$
      MathFields[FocusedMathFieldId].mf.keystroke("Shift-Left");//selects $#!$
      EditingMathFields = false;//we want to parse the next change because we are finished doing the intermediate steps to get the selectedString
      MathFields[FocusedMathFieldId].mf.write(`\\vec{${selectedString}}`);
      if(selectedString.length == 0){//this means the user wanted to generate a vector sign so we need to place the cursor in the right position once they generate the vector sign
        MathFields[FocusedMathFieldId].mf.keystroke("Left");
      }
      HotKeySequenceReset = false;
    }
  }
  else{
    HotKeySequenceReset = !EditorKeyPresses[91];
    if(HotKeySequenceReset){
      EditorKeyPresses = {};
    }
  }
}

function AnimateTyping(id,text){
  if(text.length > 0){
    MathFields[id].mf.typedText(text[0]);
    setTimeout(function(id,t){
      AnimateTyping(id,t)
    }, 500, id, text.substring(1));
  }
}

function CreateInfoPopup(id, info){
  let html = ejs.render(Templates["video-info-popup"], {id: id, info: info});
  $("#main-screen").append(html);
  //after we append the popup to the document we need to initialize its carousels
  $(`#${id} .carousel.carousel-slider`).carousel({fullWidth: true, indicators: true});
  //adding event listener
  $(`#${id}.more-information-videos-container`).mouseout(function(e){
    //this if statement is say that the thing that cause the mouseout can't be an element inside the popup or the static physics equation that caused the popup to show if you want the popup to go away
    if($(this).find(e.relatedTarget).length == 0 && !$(e.relatedTarget).hasClass('static-physics-equation-header') && $(e.relatedTarget).parents('.static-physics-equation-header').length == 0){
      //this means that the mouseout happened because the user moved away from the video info container
      HideInfoPopup($(this).attr("id"));
    }
  });
}

function DisplayInfoPopup(id, position){
  $(`#${id}.more-information-videos-container`).css({
    "z-index": 2,
    "top": position.top,
    "left": position.left - $(`#${id}.more-information-videos-container`).width() - 10,
  });
  $(`#${id}.more-information-videos-container`).addClass("active");
}

function SelectInfoPopup(id){
  $(`#${id}.more-information-videos-container`).addClass("selected");
}

function HideInfoPopup(id){
  $(`#${id}.more-information-videos-container`).removeClass("active");
  $(`#${id}.more-information-videos-container`).removeClass("selected");
  $(`#${id}.more-information-videos-container`).css({
    "z-index": -10,
    "top": 0,
    "left": 0,
  });
}

function PlayInfoVideo(id){
  let info = JSON.parse($(`#${id}.more-information-videos-container`).attr("info"));
  let index = M.Carousel.getInstance($(`#${id} .carousel.carousel-slider`)[0]).center;
  let html = ejs.render(Templates["video-iframe-container"], {iframe: info.videos[index].iframe});
  //now we need to display the videos iframe
  $(".video-iframe-container").remove();//remove any existing videos
  HideInfoPopup(id);//remove the popup because now we are about to show the video
  $("#main-screen").append(html);
}

function CloseIframe(){
  $(".video-iframe-container").remove();
}


function DisplayLoadingBar(display){
  if(display){
    $("#parsing-changes-loading-bar").css("visibility","visible");
  }else{
    $("#parsing-changes-loading-bar").css("visibility","hidden");
  }
}


const debounce = (func, wait) => {
  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // `wait` milliseconds.
  let timeout;

  // This is the function that is returned and will be executed many times
  // We spread (...args) to capture any number of parameters we want to pass
  return function executedFunction(...args) {

    // The callback function to be executed after 
    // the debounce time has elapsed
    const later = () => {
      // null timeout to indicate the debounce ended
      timeout = null;
      
      // Execute the callback
      func(...args);
    };
    // This will reset the waiting every function execution.
    // This is the step that prevents the function from
    // being executed because it will never reach the 
    // inside of the previous setTimeout  
    clearTimeout(timeout);
    
    // Restart the debounce waiting period.
    // setTimeout returns a truthy value (it differs in web vs Node)
    timeout = setTimeout(later, wait);
  };
};
